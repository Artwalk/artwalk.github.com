<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Concurrency Programming Guide感觉线程相关的面试题都能在 👆 这个 🔗 里找到答案呢 👇 是 Google AI 翻译 (jifan) 介绍并发是指同时发生多件事的概念。随着多核 CPU 的激增以及每个处理器中核数只会增加的认识，软件开发人员需要新的方法来利用它们。尽管 OS X 和 iOS 之类的操作系统能够并行运行多个程序，但是其中大多数程序都在后台运行，并执">
<meta name="keywords" content="iOS,Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="Concurrency Programming Guide">
<meta property="og:url" content="https:&#x2F;&#x2F;leihao0.github.io&#x2F;2020&#x2F;05&#x2F;27&#x2F;Concurrency-Programming-Guide&#x2F;index.html">
<meta property="og:site_name" content="LeiHao&#39;s Blog">
<meta property="og:description" content="Concurrency Programming Guide感觉线程相关的面试题都能在 👆 这个 🔗 里找到答案呢 👇 是 Google AI 翻译 (jifan) 介绍并发是指同时发生多件事的概念。随着多核 CPU 的激增以及每个处理器中核数只会增加的认识，软件开发人员需要新的方法来利用它们。尽管 OS X 和 iOS 之类的操作系统能够并行运行多个程序，但是其中大多数程序都在后台运行，并执">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-05-27T06:28:31.264Z">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/logo.png">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/logo-192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/logo-192.png">
          
        
    
    <!-- title -->
    <title>Concurrency Programming Guide</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="LeiHao&#39;s Blog" type="application/atom+xml" />
    
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/donate/">Donate</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/05/27/Threading-Programming-Guide/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/05/07/The-Graveyard-Book/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&text=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&is_video=false&description=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Concurrency Programming Guide&body=Check out this article: https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/" target="_blank" rel="noopener"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&name=Concurrency Programming Guide&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&t=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Concurrency-Programming-Guide"><span class="toc-number">1.</span> <span class="toc-text">Concurrency Programming Guide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本文件的组织"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">本文件的组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有关术语的注释"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">有关术语的注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#也可以看看"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">也可以看看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发与应用程序设计"><span class="toc-number">1.2.</span> <span class="toc-text">并发与应用程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#远离线程"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">远离线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#调度队列"><span class="toc-number">1.2.0.1.0.1.</span> <span class="toc-text">调度队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#派遣来源"><span class="toc-number">1.2.0.1.0.2.</span> <span class="toc-text">派遣来源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#操作队列"><span class="toc-number">1.2.0.1.0.3.</span> <span class="toc-text">操作队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步设计技术"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">异步设计技术</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#定义应用程序的预期行为"><span class="toc-number">1.2.0.2.0.1.</span> <span class="toc-text">定义应用程序的预期行为</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#排除可执行的工作单元"><span class="toc-number">1.2.0.2.0.2.</span> <span class="toc-text">排除可执行的工作单元</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#确定您需要的队列"><span class="toc-number">1.2.0.2.0.3.</span> <span class="toc-text">确定您需要的队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#提高效率的技巧"><span class="toc-number">1.2.0.2.0.4.</span> <span class="toc-text">提高效率的技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能影响"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">性能影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发和其他技术"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">并发和其他技术</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#OpenCL-和并发"><span class="toc-number">1.2.0.4.0.1.</span> <span class="toc-text">OpenCL 和并发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#何时使用线程"><span class="toc-number">1.2.0.4.0.2.</span> <span class="toc-text">何时使用线程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作队列-1"><span class="toc-number">1.3.</span> <span class="toc-text">操作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于操作对象"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">关于操作对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行与非并行操作"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">并行与非并行操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个-NSInvocationOperation-对象"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">创建一个 NSInvocationOperation 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个-NSBlockOperation-对象"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">创建一个 NSBlockOperation 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义自定义操作对象"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">定义自定义操作对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#执行主要任务"><span class="toc-number">1.3.0.5.0.1.</span> <span class="toc-text">执行主要任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#响应取消事件"><span class="toc-number">1.3.0.5.0.2.</span> <span class="toc-text">响应取消事件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#配置并发执行操作"><span class="toc-number">1.3.0.5.0.3.</span> <span class="toc-text">配置并发执行操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#保持-KVO-合规性"><span class="toc-number">1.3.0.5.0.4.</span> <span class="toc-text">保持 KVO 合规性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义操作对象的执行行为"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">自定义操作对象的执行行为</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#配置互操作依赖性"><span class="toc-number">1.3.0.6.0.1.</span> <span class="toc-text">配置互操作依赖性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更改工序的执行优先级"><span class="toc-number">1.3.0.6.0.2.</span> <span class="toc-text">更改工序的执行优先级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更改底层线程优先级"><span class="toc-number">1.3.0.6.0.3.</span> <span class="toc-text">更改底层线程优先级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#设定完成区块"><span class="toc-number">1.3.0.6.0.4.</span> <span class="toc-text">设定完成区块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实施操作对象的技巧"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">实施操作对象的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#管理操作对象中的内存"><span class="toc-number">1.3.0.7.0.1.</span> <span class="toc-text">管理操作对象中的内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#处理错误和异常"><span class="toc-number">1.3.0.7.0.2.</span> <span class="toc-text">处理错误和异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确定操作对象的适当范围"><span class="toc-number">1.3.0.8.</span> <span class="toc-text">确定操作对象的适当范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行操作"><span class="toc-number">1.3.0.9.</span> <span class="toc-text">执行操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将操作添加到操作队列"><span class="toc-number">1.3.0.9.0.1.</span> <span class="toc-text">将操作添加到操作队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#手动执行操作"><span class="toc-number">1.3.0.9.0.2.</span> <span class="toc-text">手动执行操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#取消操作"><span class="toc-number">1.3.0.9.0.3.</span> <span class="toc-text">取消操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#等待操作完成"><span class="toc-number">1.3.0.9.0.4.</span> <span class="toc-text">等待操作完成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#挂起和恢复队列"><span class="toc-number">1.3.0.9.0.5.</span> <span class="toc-text">挂起和恢复队列</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度队列-1"><span class="toc-number">1.4.</span> <span class="toc-text">调度队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于调度队列"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">关于调度队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列相关技术"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">队列相关技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用块实现任务"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">使用块实现任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建和管理调度队列"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">创建和管理调度队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#获取全局并发调度队列"><span class="toc-number">1.4.0.4.0.1.</span> <span class="toc-text">获取全局并发调度队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#创建串行调度队列"><span class="toc-number">1.4.0.4.0.2.</span> <span class="toc-text">创建串行调度队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在运行时获取通用队列"><span class="toc-number">1.4.0.4.0.3.</span> <span class="toc-text">在运行时获取通用队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#调度队列的内存管理"><span class="toc-number">1.4.0.4.0.4.</span> <span class="toc-text">调度队列的内存管理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#使用队列存储自定义上下文信息"><span class="toc-number">1.4.0.4.0.5.</span> <span class="toc-text">使用队列存储自定义上下文信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#提供队列的清理功能"><span class="toc-number">1.4.0.4.0.6.</span> <span class="toc-text">提供队列的清理功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将任务添加到队列"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">将任务添加到队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将单个任务添加到队列"><span class="toc-number">1.4.0.5.0.1.</span> <span class="toc-text">将单个任务添加到队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#完成任务后执行补全"><span class="toc-number">1.4.0.5.0.2.</span> <span class="toc-text">完成任务后执行补全</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同时执行循环迭代"><span class="toc-number">1.4.0.5.0.3.</span> <span class="toc-text">同时执行循环迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在主线程上执行任务"><span class="toc-number">1.4.0.5.0.4.</span> <span class="toc-text">在主线程上执行任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在任务中使用-Objective-C-对象"><span class="toc-number">1.4.0.5.0.5.</span> <span class="toc-text">在任务中使用 Objective-C 对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂起和恢复队列-1"><span class="toc-number">1.4.0.6.</span> <span class="toc-text">挂起和恢复队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用调度信号量来调节有限资源的使用"><span class="toc-number">1.4.0.7.</span> <span class="toc-text">使用调度信号量来调节有限资源的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待排队的任务组"><span class="toc-number">1.4.0.8.</span> <span class="toc-text">等待排队的任务组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度队列和线程安全"><span class="toc-number">1.4.0.9.</span> <span class="toc-text">调度队列和线程安全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#派遣来源-1"><span class="toc-number">1.5.</span> <span class="toc-text">派遣来源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于调度源"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">关于调度源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建调度源"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">创建调度源</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#编写和安装事件处理程序"><span class="toc-number">1.5.0.2.0.1.</span> <span class="toc-text">编写和安装事件处理程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#安装取消处理程序"><span class="toc-number">1.5.0.2.0.2.</span> <span class="toc-text">安装取消处理程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更改目标队列"><span class="toc-number">1.5.0.2.0.3.</span> <span class="toc-text">更改目标队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#将自定义数据与调度源关联"><span class="toc-number">1.5.0.2.0.4.</span> <span class="toc-text">将自定义数据与调度源关联</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#调度源的内存管理"><span class="toc-number">1.5.0.2.0.5.</span> <span class="toc-text">调度源的内存管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度源示例"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">调度源示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#创建一个计时器"><span class="toc-number">1.5.0.3.0.1.</span> <span class="toc-text">创建一个计时器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#从描述符读取数据"><span class="toc-number">1.5.0.3.0.2.</span> <span class="toc-text">从描述符读取数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#将数据写入描述符"><span class="toc-number">1.5.0.3.0.3.</span> <span class="toc-text">将数据写入描述符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#监视文件系统对象"><span class="toc-number">1.5.0.3.0.4.</span> <span class="toc-text">监视文件系统对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#监控信号"><span class="toc-number">1.5.0.3.0.5.</span> <span class="toc-text">监控信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#监控过程"><span class="toc-number">1.5.0.3.0.6.</span> <span class="toc-text">监控过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消派遣源"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">取消派遣源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂起和恢复派遣源"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">挂起和恢复派遣源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远离线程-1"><span class="toc-number">1.6.</span> <span class="toc-text">远离线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用调度队列替换线程"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">用调度队列替换线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消除基于锁的代码"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">消除基于锁的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#实现异步锁"><span class="toc-number">1.6.0.2.0.1.</span> <span class="toc-text">实现异步锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同步执行关键部分"><span class="toc-number">1.6.0.2.0.2.</span> <span class="toc-text">同步执行关键部分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改进循环代码"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">改进循环代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换线程连接"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">替换线程连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更改生产者-消费者实施"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">更改生产者-消费者实施</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换信号量代码"><span class="toc-number">1.6.0.6.</span> <span class="toc-text">替换信号量代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换运行循环代码"><span class="toc-number">1.6.0.7.</span> <span class="toc-text">替换运行循环代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与-POSIX-线程的兼容性"><span class="toc-number">1.6.0.8.</span> <span class="toc-text">与 POSIX 线程的兼容性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#词汇表"><span class="toc-number">1.7.</span> <span class="toc-text">词汇表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文档修订历史"><span class="toc-number">1.8.</span> <span class="toc-text">文档修订历史</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Concurrency Programming Guide
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">LeiHao's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-05-27T06:07:04.000Z" itemprop="datePublished">2020-05-27</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Interview/" rel="tag">Interview</a>, <a class="tag-link" href="/tags/iOS/" rel="tag">iOS</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Concurrency-Programming-Guide"><a href="#Concurrency-Programming-Guide" class="headerlink" title="Concurrency Programming Guide"></a><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1" target="_blank" rel="noopener">Concurrency Programming Guide</a></h1><p>感觉线程相关的面试题都能在 👆 这个 🔗 里找到答案呢</p>
<p>👇 是 Google AI 翻译 (jifan)</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>并发是指同时发生多件事的概念。随着多核 CPU 的激增以及每个处理器中核数只会增加的认识，软件开发人员需要新的方法来利用它们。尽管 OS X 和 iOS 之类的操作系统能够并行运行多个程序，但是其中大多数程序都在后台运行，并执行需要很少的连续处理器时间的任务。当前的前台应用程序既可以吸引用户的注意力，又可以使计算机保持繁忙。如果应用程序有很多工作要做，但只占用了一部分可用内核，那么这些额外的处理资源就会被浪费掉。</p>
<p>过去，将并发引入应用程序需要创建一个或多个其他线程。不幸的是，编写线程代码具有挑战性。线程是必须手动管理的低级工具。鉴于应用程序的最佳线程数可以根据当前系统负载和底层硬件动态变化，因此即使不是不可能实现，实现正确的线程解决方案也变得非常困难。另外，通常与线程一起使用的同步机制增加了软件设计的复杂性和风险，而没有任何保证性能提高的保证。</p>
<p>与传统的基于线程的系统和应用程序相比，OS X 和 iOS 都采用了更多的异步方法来执行并发任务。应用程序无需直接创建线程，而仅需要定义特定任务，然后让系统执行它们。通过让系统管理线程，应用程序可以获得原始线程无法实现的可伸缩性级别。应用程序开发人员还可以获得更简单，更有效的编程模型。</p>
<p>本文档介绍了应在应用程序中实现并发的一种或多种技术。本文档中描述的技术在 OS X 和 iOS 中均可用。</p>
<h4 id="本文件的组织"><a href="#本文件的组织" class="headerlink" title="本文件的组织"></a>本文件的组织</h4><p>本文档包含以下章节：</p>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW1" target="_blank" rel="noopener">并发和应用程序设计</a>介绍了异步应用程序设计的基础知识以及用于异步执行自定义任务的技术。</li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1" target="_blank" rel="noopener">“操作队列”</a>向您展示了如何使用 Objective-C 对象封装和执行任务。</li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1" target="_blank" rel="noopener">调度队列</a>显示了如何在基于 C 的应用程序中同时执行任务。</li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">调度源</a>向您展示如何异步处理系统事件。</li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1" target="_blank" rel="noopener">远离线程迁移</a>提供了一些技巧和技术，可以将现有的基于线程的代码迁移到新的技术上。</li>
</ul>
<p>本文档还包括定义相关术语的词汇表。</p>
<h4 id="有关术语的注释"><a href="#有关术语的注释" class="headerlink" title="有关术语的注释"></a>有关术语的注释</h4><p>在讨论并发之前，有必要定义一些相关术语以防止混淆。对 UNIX 系统或较早的 OS X 技术更加熟悉的开发人员可能会在本文中发现“任务”，“进程”和“线程”这两个词的用法有所不同。本文档以下列方式使用这些术语：</p>
<ul>
<li>术语<em>线程</em>用于指代代码的独立执行路径。OS X 中线程的基础实现基于 POSIX 线程 API。</li>
<li>术语“ <em>进程”</em>用于指代一个正在运行的可执行文件，它可以包含多个线程。</li>
<li>术语“ <em>任务”</em>用于指代需要执行的工作的抽象概念。</li>
</ul>
<p>有关本文档使用的这些术语和其他关键术语的完整定义，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW2" target="_blank" rel="noopener">词汇表</a>。</p>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><p>本文档重点介绍在您的应用程序中实现并发性的首选技术，并且不涉及线程的使用。如果您需要有关使用线程和其他线程相关技术的信息，请参见《_<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i" target="_blank" rel="noopener">线程编程指南》</a>_。</p>
<h2 id="并发与应用程序设计"><a href="#并发与应用程序设计" class="headerlink" title="并发与应用程序设计"></a>并发与应用程序设计</h2><p>在计算的早期，计算机可以执行的每单位时间的最大工作量取决于 CPU 的时钟速度。但是，随着技术的进步和处理器设计变得更加紧凑，热量和其他物理限制开始限制处理器的最大时钟速度。因此，芯片制造商正在寻找其他方法来提高其芯片的总体性能。他们确定的解决方案是增加每个芯片上的处理器内核数量。通过增加内核数量，单个芯片可以每秒执行更多指令，而无需提高 CPU 速度或更改芯片尺寸或散热特性。唯一的问题是如何利用额外的内核。</p>
<p>为了利用多个内核，计算机需要可以同时执行多项操作的软件。对于像 OS X 或 iOS 这样的现代多任务操作系统，在任何给定时间可以运行一百个或更多程序，因此应该可以在不同的内核上调度每个程序。但是，这些程序大多数是系统守护程序或后台应用程序，它们消耗很少的实际处理时间。相反，真正需要的是使各个应用程序更有效地利用额外内核的方式。</p>
<p>应用程序使用多个内核的传统方式是创建多个线程。但是，随着内核数量的增加，线程解决方案存在问题。最大的问题是线程代码无法很好地扩展到任意数量的内核。您不能创建与内核一样多的线程，并且期望程序运行良好。您需要知道的是可以有效使用的内核数量，这对于应用程序自己进行计算是一项挑战。即使您设法使数字正确，也仍然面临着对如此多的线程进行编程，使其高效运行以及防止它们相互干扰的挑战。</p>
<p>因此，总结问题，需要为应用程序提供一种利用可变数量的计算机内核的方法。单个应用程序执行的工作量还需要能够动态扩展以适应不断变化的系统条件。解决方案必须足够简单，以免增加利用这些内核所需的工作量。好消息是，Apple 的操作系统为所有这些问题提供了解决方案，本章介绍了构成该解决方案的技术以及可以对代码进行的设计调整，以利用它们。</p>
<h4 id="远离线程"><a href="#远离线程" class="headerlink" title="远离线程"></a>远离线程</h4><p>尽管线程已经存在很多年了并且继续使用它们，但是它们并不能解决以可伸缩方式执行多个任务的一般问题。使用线程，创建可伸缩解决方案的负担完全由开发人员承担。您必须决定要创建多少个线程，并随着系统条件的变化动态地调整该数量。另一个问题是您的应用程序承担了与创建和维护其使用的任何线程相关的大部分成本。</p>
<p>OS X 和 iOS 无需依赖线程，而是采用<em>异步设计方法</em>解决并发问题。异步功能已经存在于操作系统中多年，通常用于启动可能需要很长时间的任务，例如从磁盘读取数据。调用异步函数时，它会在后台执行一些工作以启动任务运行，但在该任务可能实际完成之前返回。通常，这项工作涉及获取后台线程，在该线程上启动所需的任务，然后在任务完成时向调用者发送通知（通常通过回调函数）。过去，如果要执行的操作不存在异步函数，则必须编写自己的异步函数并创建自己的线程。但现在，</p>
<p>异步启动任务的技术之一是<em>大中央调度（GCD）</em>。该技术采用了您通常在自己的应用程序中编写的线程管理代码，并将该代码下移至系统级别。您所要做的就是定义要执行的任务，并将其添加到适当的调度队列中。GCD 负责创建所需的线程，并安排任务在这些线程上运行。由于线程管理现在是系统的一部分，因此 GCD 提供了一种用于任务管理和执行的整体方法，比传统线程提供了更高的效率。</p>
<p><em>操作队列</em>是 Objective-C 对象，其行为与分派队列非常相似。您定义要执行的任务，然后将它们添加到操作队列中，该队列处理这些任务的调度和执行。与 GCD 一样，操作队列为您处理所有线程管理，以确保任务在系统上尽可能快且高效地执行。</p>
<p>以下各节提供有关可在应用程序中使用的调度队列，操作队列和其他一些相关异步技术的更多信息。</p>
<h6 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h6><p>调度队列是用于执行自定义任务的基于 C 的机制。一个<em>调度队列</em>执行任务的顺序或同时却总是先入先出的顺序。（换句话说，调度队列始终以添加任务到队列的顺序出队列并启动任务。）串行调度队列一次仅运行一个任务，直到该任务完成后才出队列并启动任务。新的一个。相比之下，并发调度队列可以启动尽可能多的任务，而不必等待已经启动的任务完成。</p>
<p>调度队列还有其他好处：</p>
<ul>
<li>它们提供了简单明了的编程界面。</li>
<li>它们提供自动的整体线程池管理。</li>
<li>它们提供了调优装配的速度。</li>
<li>它们具有更高的内存效率（因为线程堆栈不会停留在应用程序内存中）。</li>
<li>它们不会在负载下捕获到内核。</li>
<li>任务到调度队列的异步调度不能使队列死锁。</li>
<li>他们在竞争中优雅地扩展。</li>
<li>串行分派队列为锁和其他同步原语提供了更有效的替代方法。</li>
</ul>
<p>您提交给分派队列的任务必须封装在函数或块对象中。<em>块对象</em>是 OS X v10.6 和 iOS 4.0 中引入的 C 语言功能，从概念上讲类似于函数指针，但还有一些其他好处。通常，不是在自己的词法范围内定义块，而是通常在另一个函数或方法内定义块，以便它们可以从该函数或方法访问其他变量。块也可以移出其原始范围并复制到堆上，这是将它们提交到调度队列时发生的情况。所有这些语义使得使用相对较少的代码即可实现非常动态的任务。</p>
<p>调度队列是 Grand Central Dispatch 技术的一部分，并且是 C 运行时的一部分。有关在应用程序中使用调度队列的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1" target="_blank" rel="noopener">调度队列</a>。有关块及其好处的更多信息，请参见*<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">块编程主题</a>*。</p>
<h6 id="派遣来源"><a href="#派遣来源" class="headerlink" title="派遣来源"></a>派遣来源</h6><p>调度源是一种基于 C 的机制，用于异步处理特定类型的系统事件。调度源封装有关特定类型系统事件的信息，并在该事件发生时将特定的块对象或功能提交给调度队列。您可以使用调度源来监视以下类型的系统事件：</p>
<ul>
<li>计时器</li>
<li>信号处理器</li>
<li>描述符相关事件</li>
<li>与流程相关的事件</li>
<li>马赫港口事件</li>
<li>您触发的自定义事件</li>
</ul>
<p>调度源是大中央调度技术的一部分。有关使用调度源接收应用程序中的事件的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">调度源</a>。</p>
<h6 id="操作队列"><a href="#操作队列" class="headerlink" title="操作队列"></a>操作队列</h6><p>操作队列在 Cocoa 中等同于并发调度队列，由<code>NSOperationQueue</code>类实现。调度队列始终按先进先出的顺序执行任务，而操作队列在确定任务的执行顺序时会考虑其他因素。这些因素中最主要的是给定任务是否取决于其他任务的完成。您可以在定义任务时配置依赖关系，并可以使用它们来为任务创建复杂的执行顺序图。</p>
<p>您提交给操作队列的任务必须是<code>NSOperation</code>该类的实例。的<em>操作对象</em>是 Objective-C 的对象，它封装了要执行的工作，并执行它所需要的任何数据。因为<code>NSOperation</code>该类实质上是抽象基类，所以通常定义自定义子类来执行任务。但是，Foundation 框架确实包含一些具体的子类，您可以直接创建和使用这些子类来执行任务。</p>
<p>操作对象会生成键值观察（KVO）通知，这可以是监视任务进度的有用方法。尽管操作队列总是同时执行操作，但是您可以使用依赖项来确保在需要时按顺序执行它们。</p>
<p>有关如何使用操作队列以及如何定义自定义操作对象的更多信息，请参见《<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1" target="_blank" rel="noopener">操作队列》</a>。</p>
<h4 id="异步设计技术"><a href="#异步设计技术" class="headerlink" title="异步设计技术"></a>异步设计技术</h4><p>在甚至考虑重新设计代码以支持并发之前，您应该问自己是否这样做。并发可以确保您的主线程可以自由地响应用户事件，从而可以提高代码的响应速度。通过利用更多的内核在相同的时间内完成更多的工作，它甚至可以提高代码的效率。但是，这也增加了开销并增加了代码的整体复杂性，从而使编写和调试代码变得更加困难。</p>
<p>因为并发性增加了复杂性，所以您不能在产品周期结束时将并发性移植到应用程序上。正确执行此操作需要仔细考虑应用程序执行的任务以及用于执行这些任务的数据结构。如果处理不正确，您可能会发现代码运行速度比以前慢，并且对用户的响应速度也较慢。因此，值得在设计周期开始时花一些时间设定一些目标并考虑需要采取的方法。</p>
<p>每个应用程序都有不同的要求和执行的不同任务集。文档不可能准确地告诉您如何设计应用程序及其相关任务。但是，以下各节试图提供一些指导，以帮助您在设计过程中做出正确的选择。</p>
<h6 id="定义应用程序的预期行为"><a href="#定义应用程序的预期行为" class="headerlink" title="定义应用程序的预期行为"></a>定义应用程序的预期行为</h6><p>在甚至考虑向应用程序添加并发之前，您应该始终从定义您认为正确的应用程序行为开始。了解应用程序的预期行为为您提供了一种稍后验证设计的方法。它还应该使您对通过引入并发可能获得的预期性能收益有所了解。</p>
<p>您应该做的第一件事是枚举应用程序执行的任务以及与每个任务关联的对象或数据结构。最初，您可能想从用户选择菜单项或单击按钮时执行的任务开始。这些任务提供了离散的行为，并具有明确定义的起点和终点。您还应该枚举应用程序无需用户交互即可执行的其他类型的任务，例如基于计时器的任务。</p>
<p>在获得高级任务列表之后，开始将每个任务进一步细分为成功完成任务必须采取的步骤。在此级别上，您应该主要关注需要对任何数据结构和对象进行的修改，以及这些修改如何影响应用程序的整体状态。您还应该注意对象与数据结构之间的任何依赖关系。例如，如果一项任务涉及对一组对象进行相同的更改，则值得注意的是对一个对象的更改是否会影响其他任何对象。如果可以相互独立地修改对象，则可能是可以同时进行这些修改的地方。</p>
<h6 id="排除可执行的工作单元"><a href="#排除可执行的工作单元" class="headerlink" title="排除可执行的工作单元"></a>排除可执行的工作单元</h6><p>通过了解应用程序的任务，您应该已经能够确定代码可以从并发中受益的地方。如果更改任务中一个或多个步骤的顺序会改变结果，则可能需要继续按顺序继续执行这些步骤。但是，如果更改顺序对输出没有影响，则应考虑同时执行这些步骤。在这两种情况下，您都定义了代表要执行的一个或多个步骤的可执行工作单元。然后，该工作单元将成为您使用块或操作对象封装的内容，并分派到适当的队列中。</p>
<p>对于您标识的每个可执行工作单元，至少在最初阶段，不必过多担心执行的工作量。尽管拆分线程始终会产生成本，但是分派队列和操作队列的优点之一是，在许多情况下，这些成本比传统线程要小得多。因此，与使用线程相比，使用队列可以更有效地执行较小的工作单元。当然，您应该始终测量实际性能并根据需要调整任务的大小，但是一开始，不应将任何任务视为太小。</p>
<h6 id="确定您需要的队列"><a href="#确定您需要的队列" class="headerlink" title="确定您需要的队列"></a>确定您需要的队列</h6><p>现在，您的任务已分解为不同的工作单元，并使用块对象或操作对象进行了封装，现在您需要定义要用于执行该代码的队列。对于给定的任务，请检查您创建的块或操作对象以及必须执行它们才能正确执行任务的顺序。</p>
<p>如果使用块来实现任务，则可以将块添加到串行或并发调度队列中。如果需要特定的命令，则始终将块添加到串行调度队列中。如果不需要特定的顺序，则可以根据需要将块添加到并发调度队列中，或将它们添加到几个不同的调度队列中。</p>
<p>如果使用操作对象实现任务，则选择队列通常比配置对象有趣。要串行执行操作对象，必须配置相关对象之间的依赖关系。依赖关系会阻止一个操作执行到它所依赖的对象完成工作为止。</p>
<h6 id="提高效率的技巧"><a href="#提高效率的技巧" class="headerlink" title="提高效率的技巧"></a>提高效率的技巧</h6><p>除了简单地将代码分解为较小的任务并将其添加到队列之外，还有其他方法可以使用队列来提高代码的整体效率：</p>
<ul>
<li><strong>如果内存使用是一个因素，请考虑直接在任务中计算值。</strong>如果您的应用程序已经受内存限制，那么现在直接计算值可能比从主内存加载缓存的值要快。计算值直接使用给定处理器内核的寄存器和缓存，这比主内存快得多。当然，只有在测试表明这是性能上的胜利时，才应该这样做。</li>
<li><strong>尽早识别串行任务，并尽力使它们更加并行。</strong>如果由于某个任务依赖某些共享资源而必须串行执行该任务，请考虑更改体系结构以删除该共享资源。您可以考虑为每个需要一个的客户端制作资源副本，或者完全消除该资源。</li>
<li><strong>避免使用锁。</strong>分派队列和操作队列提供的支持使得在大多数情况下不需要锁。与其使用锁来保护某些共享资源，不如指定一个串行队列（或使用操作对象依赖项）以正确的顺序执行任务。</li>
<li><strong>尽可能依靠系统框架。</strong>实现并发的最佳方法是利用系统框架提供的内置并发。许多框架在内部使用线程和其他技术来实现并发行为。在定义任务时，请查看现有框架是否定义了可以完全满足您期望并同时实现的功能或方法。使用该 API 可以节省您的精力，并且更有可能为您提供最大的并发性。</li>
</ul>
<h4 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h4><p>提供了操作队列，调度队列和调度源，使您可以更轻松地同时执行更多代码。但是，这些技术不能保证提高应用程序的效率或响应能力。使用队列既可以满足您的需求，又不会给应用程序的其他资源带来过多负担，仍然是您的责任。例如，尽管您可以创建 10,000 个操作对象并将其提交到操作队列，但是这样做将导致您的应用程序分配潜在的重要内存量，这可能导致分页和性能下降。</p>
<p>在为代码引入任何数量的并发之前（无论使用队列还是线程），您应该始终收集一组反映应用程序当前性能的基准度量。引入更改后，您应该收集其他指标并将其与基准进行比较，以查看应用程序的整体效率是否有所提高。如果并发性引入使您的应用程序效率或响应速度降低，则应使用可用的性能工具来检查潜在原因。</p>
<p>有关性能和可用性能工具的介绍，以及指向更多与性能相关的高级主题的链接，请参见*<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" target="_blank" rel="noopener">性能概述</a>*。</p>
<h4 id="并发和其他技术"><a href="#并发和其他技术" class="headerlink" title="并发和其他技术"></a>并发和其他技术</h4><p>将代码分解为模块化任务是尝试并提高应用程序中并发性的最佳方法。但是，这种设计方法可能无法满足每种情况下每种应用程序的需求。根据您的任务，可能还有其他选项可以为应用程序的整体并发性提供其他改进。本节概述了设计中要考虑使用的其他一些技术。</p>
<h6 id="OpenCL-和并发"><a href="#OpenCL-和并发" class="headerlink" title="OpenCL 和并发"></a>OpenCL 和并发</h6><p>在 OS X 中，<em>开放计算语言（OpenCL）</em>是一种基于标准的技术，用于在计算机的图形处理器上执行通用计算。如果您要对大型数据集应用一组定义明确的计算，则 OpenCL 是一项很好的技术。例如，您可以使用 OpenCL 对图像的像素执行过滤器计算，或一次对多个值执行复杂的数学计算。换句话说，OpenCL 更适合问题集，这些问题集的数据可以并行处理。</p>
<p>尽管 OpenCL 可以很好地执行大量数据并行操作，但它不适用于更通用的计算。将数据和所需的工作内核准备并传输到图形卡需要大量的精力，以便可以通过 GPU 对其进行操作。同样，检索 OpenCL 生成的任何结果都需要花费大量精力。因此，通常不建议与系统交互的任何任务与 OpenCL 一起使用。例如，您不会使用 OpenCL 处理文件或网络流中的数据。相反，您使用 OpenCL 执行的工作必须更加独立，以便可以将其传输到图形处理器并进行独立计算。</p>
<p>有关 OpenCL 及其使用方式的详细信息，请参阅*<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/OpenCL_MacProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008312" target="_blank" rel="noopener">《适用于 Mac 的 OpenCL 编程指南》</a>*。</p>
<h6 id="何时使用线程"><a href="#何时使用线程" class="headerlink" title="何时使用线程"></a>何时使用线程</h6><p>尽管操作队列和调度队列是同时执行任务的首选方式，但它们不是万能药。根据您的应用程序，有时仍然需要创建自定义线程。如果确实创建自定义线程，则应努力自己创建尽可能少的线程，并且应仅将这些线程用于无法以其他任何方式实现的特定任务。</p>
<p>线程仍然是实现必须实时运行的代码的好方法。调度队列会尽一切努力尽可能快地运行其任务，但不能解决实时约束。如果您需要从后台运行的代码中获得更多可预测的行为，则线程可能仍然是更好的选择。</p>
<p>与任何线程编程一样，您应始终明智地使用线程，并且仅在绝对必要时使用。有关线程包及其使用方式的更多信息，请参见《_<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i" target="_blank" rel="noopener">线程编程指南》</a>_。</p>
<h2 id="操作队列-1"><a href="#操作队列-1" class="headerlink" title="操作队列"></a>操作队列</h2><p>可可操作是一种面向对象的方法，用于封装要异步执行的工作。操作被设计为与操作队列结合使用或单独使用。由于它们基于 Objective-C，因此在 OS X 和 iOS 的基于 Cocoa 的应用程序中最常使用操作。</p>
<p>本章介绍如何定义和使用操作。</p>
<h4 id="关于操作对象"><a href="#关于操作对象" class="headerlink" title="关于操作对象"></a>关于操作对象</h4><p>的<em>操作对象</em>是的实例<code>NSOperation</code>类（Foundation 框架），您使用您希望您的应用程序执行封装工作。在<code>NSOperation</code>类本身是一个抽象基类，必须按顺序做任何有用的工作被继承。尽管是抽象类，但此类确实提供了大量的基础结构，以最大程度地减少您必须在自己的子类中完成的工作量。另外，Foundation 框架提供了两个具体的子类，您可以按原样使用现有代码。表 2-1 列出了这些类，以及如何使用每种类的摘要。</p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NSInvocationOperation</code></td>
<td align="left">您原样使用的类基于应用程序中的对象和选择器创建操作对象。如果您具有已经执行所需任务的现有方法，则可以使用此类。由于不需要子类，因此您也可以使用此类以更动态的方式创建操作对象。有关如何使用此类的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW6" target="_blank" rel="noopener">创建 NSInvocationOperation 对象</a>。</td>
</tr>
<tr>
<td align="left"><code>NSBlockOperation</code></td>
<td align="left">按原样使用的类可同时执行一个或多个块对象。因为可以执行多个块，所以块操作对象使用组语义进行操作；仅当所有相关块已完成执行时，操作本身才视为完成。有关如何使用此类的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW2" target="_blank" rel="noopener">创建 NSBlockOperation 对象</a>。此类在 OS X v10.6 和更高版本中可用。有关块的更多信息，请参见*<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">块编程主题</a>*。</td>
</tr>
<tr>
<td align="left"><code>NSOperation</code></td>
<td align="left">定义自定义操作对象的基类。子类化<code>NSOperation</code>使您可以完全控制自己的操作的实现，包括更改操作执行和报告其状态的默认方式的能力。有关如何定义自定义操作对象的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW16" target="_blank" rel="noopener">定义自定义操作对象</a>。</td>
</tr>
</tbody></table>
<p>所有操作对象都支持以下关键功能：</p>
<ul>
<li>支持在操作对象之间建立基于图的依赖关系。这些依赖关系会阻止给定操作运行，直到它所依赖的所有操作都已运行完毕。有关如何配置依赖关系的信息，请参阅《<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17" target="_blank" rel="noopener">配置互操作依赖关系》</a>。</li>
<li>支持可选的完成块，该块在操作的主要任务完成后执行。（仅适用于 OS X v10.6 和更高版本。）有关如何设置完成块的信息，请参阅《<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW33" target="_blank" rel="noopener">设置完成块》</a>。</li>
<li>支持使用 KVO 通知监视对操作的执行状态的更改。有关如何观察 KVO 通知的信息，请参阅《_<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="noopener">键值观察编程指南》</a>_。</li>
<li>支持对操作进行优先级排序，从而影响其相对执行顺序。有关更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW31" target="_blank" rel="noopener">更改操作的执行优先级</a>。</li>
<li>支持取消语义，使您可以在执行过程中暂停操作。有关如何取消操作的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW39" target="_blank" rel="noopener">取消操作</a>。有关如何在自己的操作中支持取消的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW24" target="_blank" rel="noopener">响应取消事件</a>。</li>
</ul>
<p>操作旨在帮助您提高应用程序中的并发级别。操作也是将应用程序的行为组织和封装为简单的离散块的好方法。您可以在一个队列中提交一个或多个操作对象，而不是在应用程序的主线程上运行一些代码，而可以在一个或多个单独的线程上异步执行相应的工作。</p>
<h4 id="并行与非并行操作"><a href="#并行与非并行操作" class="headerlink" title="并行与非并行操作"></a>并行与非并行操作</h4><p>尽管通常通过将操作添加到操作队列来执行操作，但这不是必需的。也可以通过调用操作对象的<code>start</code>方法来手动执行操作对象，但这样做不能保证操作与代码的其余部分同时运行。该类的<code>isConcurrent</code>方法<code>NSOperation</code>告诉您操作相对于<code>start</code>调用其方法的线程是同步还是异步运行。默认情况下，此方法返回<code>NO</code>，这意味着该操作在调用线程中同步运行。</p>
<p>如果要实现<em>并发操作（</em>即相对于调用线程异步运行的<em>操作</em>），则必须编写其他代码以异步启动操作。例如，您可以生成单独的线程，调用异步系统函数或执行任何其他操作以确保该<code>start</code>方法启动任务并立即返回，并且很可能在任务完成之前返回。</p>
<p>大多数开发人员永远都不需要实现并发操作对象。如果始终将操作添加到操作队列中，则无需实现并发操作。当您将非并行操作提交给操作队列时，队列本身会创建一个线程来在其上运行您的操作。因此，向操作队列中添加非并发操作仍然会导致操作目标代码的异步执行。仅在需要异步执行操作而不将其添加到操作队列的情况下，才需要定义并发操作的功能。</p>
<p>有关如何创建并发操作的信息，请参阅《<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW8" target="_blank" rel="noopener">配置</a>并发操作和*<a href="https://developer.apple.com/documentation/foundation/nsoperation" target="_blank" rel="noopener">NSOperation 类参考》</a>*。</p>
<h4 id="创建一个-NSInvocationOperation-对象"><a href="#创建一个-NSInvocationOperation-对象" class="headerlink" title="创建一个 NSInvocationOperation 对象"></a>创建一个 NSInvocationOperation 对象</h4><p>该<code>NSInvocationOperation</code>班是一个具体子类<code>NSOperation</code>是在运行时调用选择你指定的对象上注明。使用此类可避免为应用程序中的每个任务定义大量的自定义操作对象；特别是如果您正在修改现有应用程序，并且已经具有执行必要任务所需的对象和方法。当您要调用的方法可以根据情况改变时，也可以使用它。例如，您可以使用调用操作来执行根据用户输入动态选择的选择器。</p>
<p>创建调用操作的过程很简单。您创建并初始化该类的新实例，并将所需的对象和选择器传递给初始化方法。清单 2-1 显示了来自自定义类的两种方法，它们演示了创建过程。该<code>taskWithData:</code>方法创建一个新的调用对象，并为其提供另一个方法的名称，该名称包含任务实现。</p>
<p><strong>清单 2-1</strong> 创建一个<code>NSInvocationOperation</code>对象</p>
<table>
<thead>
<tr>
<th><code>@implementation MyCustomClass</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>-（NSOperation *）taskWithData：（id）data {</code></td>
</tr>
<tr>
<td><code>NSInvocationOperation * theOp = [[NSInvocationOperation alloc] initWithTarget：self</code></td>
</tr>
<tr>
<td><code>选择器：@选择器（myTaskMethod :)对象：数据];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>返回theOp;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//这是执行任务实际工作的方法。</code></td>
</tr>
<tr>
<td><code>-（void）myTaskMethod：（id）data {</code></td>
</tr>
<tr>
<td><code>//执行任务。</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
</tbody></table>
<h4 id="创建一个-NSBlockOperation-对象"><a href="#创建一个-NSBlockOperation-对象" class="headerlink" title="创建一个 NSBlockOperation 对象"></a>创建一个 NSBlockOperation 对象</h4><p>的<code>NSBlockOperation</code>类是的具体子类<code>NSOperation</code>充当用于一个或多个的包装块的对象。此类为已经在使用操作队列并且不想创建调度队列的应用程序提供面向对象的包装。您还可以使用块操作来利用操作依赖性，KVO 通知和分派队列可能不提供的其他功能。</p>
<p>创建块操作时，通常在初始化时至少添加一个块。您可以稍后根据需要添加更多块。当需要执行一个<code>NSBlockOperation</code>对象时，该对象将其所有块提交给默认优先级的并发调度队列。然后，对象等待直到所有块完成执行。当最后一个块完成执行时，操作对象将自身标记为完成。因此，您可以使用块操作来跟踪一组正在执行的块，就像使用线程联接合并来自多个线程的结果一样。区别在于，由于块操作本身在单独的线程上运行，因此应用程序的其他线程可以在等待块操作完成的同时继续进行工作。</p>
<p>清单 2-2 显示了如何创建<code>NSBlockOperation</code>对象的简单示例。该块本身没有参数，也没有明显的返回结果。</p>
<p><strong>清单 2-2</strong> 创建一个<code>NSBlockOperation</code>对象</p>
<table>
<thead>
<tr>
<th><code>NSBlockOperation * theOp = [NSBlockOperation blockOperationWithBlock：^ {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>NSLog（@“开始操作。\ n”）;</code></td>
</tr>
<tr>
<td><code>// 做一些工作。</code></td>
</tr>
<tr>
<td><code>}];</code></td>
</tr>
</tbody></table>
<p>创建块操作对象后，可以使用该<code>addExecutionBlock:</code>方法向其添加更多块。如果需要顺序执行块，则必须将它们直接提交给所需的调度队列。</p>
<h4 id="定义自定义操作对象"><a href="#定义自定义操作对象" class="headerlink" title="定义自定义操作对象"></a>定义自定义操作对象</h4><p>如果块操作和调用操作对象不能完全满足应用程序的需求，则可以<code>NSOperation</code>直接子类化并添加所需的任何行为。本<code>NSOperation</code>类提供的所有操作对象的通用子类点。该类还提供了大量的基础结构来处理依赖项和 KVO 通知所需的大部分工作。但是，有时仍然需要补充现有的基础架构以确保您的操作正常进行。您必须执行的额外工作量取决于您要实现的是非并发操作还是并发操作。</p>
<p>定义非并发操作比定义并发操作要简单得多。对于非并行操作，您所需要做的就是执行主要任务并适当地响应取消事件；现有的班级基础架构会为您完成所有其他工作。对于并发操作，必须用自定义代码替换一些现有的基础结构。以下各节向您展示如何实现两种类型的对象。</p>
<h6 id="执行主要任务"><a href="#执行主要任务" class="headerlink" title="执行主要任务"></a>执行主要任务</h6><p>每个操作对象至少应实现至少以下方法：</p>
<ul>
<li>自定义初始化方法</li>
<li><code>main</code></li>
</ul>
<p>您需要一个自定义的初始化方法来将操作对象置于已知状态，并需要一个自定义的<code>main</code>方法来执行任务。当然，您可以根据需要实现其他方法，例如：</p>
<ul>
<li>您计划从<code>main</code>方法的实现中调用的自定义方法</li>
<li>用于设置数据值和访问操作结果的访问器方法</li>
<li><code>NSCoding</code>允许您归档和取消归档操作对象的协议方法</li>
</ul>
<p>清单 2-3 显示了自定义<code>NSOperation</code>子类的起始模板。（此清单未显示如何处理取消，但显示了通常具有的方法。有关处理取消的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW24" target="_blank" rel="noopener">响应取消事件</a>。）此类的初始化方法将单个对象作为数据参数并存储一个对象。在操作对象内部对其的引用。该<code>main</code>方法表面上将对该数据对象起作用，然后再将结果返回给您的应用程序。</p>
<p><strong>清单 2-3</strong> 定义一个简单的操作对象</p>
<table>
<thead>
<tr>
<th><code>@interface MyNonConcurrentOperation：NSOperation</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>@property id（strong）myData;</code></td>
</tr>
<tr>
<td><code>-（id）initWithData：（id）数据;</code></td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>@implementation MyNonConcurrentOperation</code></td>
</tr>
<tr>
<td><code>-（id）initWithData：（id）data {</code></td>
</tr>
<tr>
<td><code>如果（自我= [超级初始化]）</code></td>
</tr>
<tr>
<td><code>myData =数据；</code></td>
</tr>
<tr>
<td><code>返回自我</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（void）main {</code></td>
</tr>
<tr>
<td><code>@尝试{</code></td>
</tr>
<tr>
<td><code>//对myData做一些工作并报告结果。</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>@catch（...）{</code></td>
</tr>
<tr>
<td><code>//不要抛出异常。</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
<tr>
<td>``</td>
</tr>
</tbody></table>
<p>有关如何实现<code>NSOperation</code>子类的详细示例，请参见*<a href="https://developer.apple.com/library/archive/samplecode/NSOperationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS10004184" target="_blank" rel="noopener">NSOperationSample</a>*。</p>
<h6 id="响应取消事件"><a href="#响应取消事件" class="headerlink" title="响应取消事件"></a>响应取消事件</h6><p>操作开始执行后，它将继续执行其任务，直到完成为止，或者直到您的代码明确取消了该操作。取消可以随时发生，甚至在操作开始执行之前。尽管<code>NSOperation</code>该类为客户提供了取消操作的方法，但是识别取消事件是必要的，是自愿的。如果操作被彻底终止，则可能没有办法回收已分配的资源。结果，期望操作对象检查取消事件，并在它们出现在操作中间时正常退出。</p>
<p>为了支持取消操作对象中的操作，您要做的就是<code>isCancelled</code>从您的自定义代码中定期调用该对象的方法，并在返回时立即返回<code>YES</code>。无论操作时间长短，是<code>NSOperation</code>直接子类化还是使用其具体子类之一，支持取消都很重要。该<code>isCancelled</code>方法本身非常轻巧，可以频繁调用而不会造成任何明显的性能损失。设计操作对象时，应考虑<code>isCancelled</code>在代码的以下位置调用该方法：</p>
<ul>
<li>在您执行任何实际工作之前</li>
<li>在循环的每次迭代中至少一次，如果每次迭代相对较长，则更频繁</li>
<li>在代码中的任何时候，相对容易中止操作</li>
</ul>
<p>清单 2-4 提供了一个非常简单的示例，说明如何以<code>main</code>操作对象的方法响应取消事件。在这种情况下，<code>isCancelled</code>每次通过<code>while</code>循环都会调用该方法，这样可以在工作开始之前快速退出，并有规律地间隔一次。</p>
<p><strong>清单 2-4</strong> 响应取消请求</p>
<table>
<thead>
<tr>
<th><code>-（void）main {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>@尝试{</code></td>
</tr>
<tr>
<td><code>BOOL isDone = NO;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>while（！[self isCancelled] &amp;&amp;！isDone）{</code></td>
</tr>
<tr>
<td><code>//做一些工作，完成后将isDone设置为YES</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>@catch（...）{</code></td>
</tr>
<tr>
<td><code>//不要抛出异常。</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>尽管前面的示例不包含清除代码，但是您自己的代码应确保释放您的自定义代码分配的所有资源。</p>
<h6 id="配置并发执行操作"><a href="#配置并发执行操作" class="headerlink" title="配置并发执行操作"></a>配置并发执行操作</h6><p>默认情况下，操作对象以同步方式执行-也就是说，它们在调用其<code>start</code>方法的线程中执行其任务。但是，由于操作队列为非并发操作提供了线程，因此大多数操作仍然异步运行。但是，如果您打算手动执行操作，但仍希望它们异步运行，则必须采取适当的措施以确保它们能够执行。通过将操作对象定义为并发操作来执行此操作。</p>
<p>表 2-2 列出了通常为实现并发操作而重写的方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>start</code></td>
<td align="left">（必需）所有并发操作都必须重写此方法，并用其自己的自定义实现替换默认行为。要手动执行操作，请调用其<code>start</code>方法。因此，此方法的实现是您操作的起点，并且是您在其中设置执行任务的线程或其他执行环境的地方。您的实现不得<code>super</code>在任何时候调用。</td>
</tr>
<tr>
<td align="left"><code>main</code></td>
<td align="left">（可选）此方法通常用于实现与操作对象关联的任务。尽管您可以在<code>start</code>方法中执行任务，但是使用此方法实现任务可以使您的设置和任务代码更加清晰。</td>
</tr>
<tr>
<td align="left"><code>isExecuting``isFinished</code></td>
<td align="left">（必需）并发操作负责设置其执行环境，并向外部客户端报告该环境的状态。因此，并发操作必须维护一些状态信息，以了解何时执行任务以及何时完成该任务。然后，必须使用这些方法报告该状态。您可以安全地同时从其他线程调用这些方法的实现。在更改这些方法报告的值时，还必须为预期的键路径生成适当的 KVO 通知。</td>
</tr>
<tr>
<td align="left"><code>isConcurrent</code></td>
<td align="left">（必需）要将操作标识为并发操作，请覆盖此方法并返回<code>YES</code>。</td>
</tr>
</tbody></table>
<p>本节的其余部分显示了<code>MyOperation</code>该类的示例实现，该示例演示了实现并发操作所需的基本代码。将<code>MyOperation</code>类简单地执行它自己的<code>main</code>一个单独的线程方法，它创造。该<code>main</code>方法执行的实际工作无关紧要。该示例的重点是演示定义并发操作时需要提供的基础结构。</p>
<p>清单 2-5 显示了<code>MyOperation</code>该类的接口和部分实现。的的实现<code>isConcurrent</code>，<code>isExecuting</code>和<code>isFinished</code>方法的<code>MyOperation</code>类是相对简单的。该<code>isConcurrent</code>方法应该简单地返回<code>YES</code>以指示这是一个并发操作。该<code>isExecuting</code>和<code>isFinished</code>方法简单地返回保存在类本身的实例变量的值。</p>
<p><strong>清单 2-5</strong> 定义并发操作</p>
<table>
<thead>
<tr>
<th><code>@interface MyOperation：NSOperation {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>布尔执行；</code></td>
</tr>
<tr>
<td><code>BOOL完成；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>-（void）completeOperation；</code></td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>@implementation MyOperation</code></td>
</tr>
<tr>
<td><code>-（id）init {</code></td>
</tr>
<tr>
<td><code>自我= [超级初始化];</code></td>
</tr>
<tr>
<td><code>如果（自己）{</code></td>
</tr>
<tr>
<td><code>执行=否;</code></td>
</tr>
<tr>
<td><code>完成=否；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>返回自我</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（BOOL）是并发{</code></td>
</tr>
<tr>
<td><code>返回是；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（BOOL）正在执行{</code></td>
</tr>
<tr>
<td><code>返回执行；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（BOOL）已完成{</code></td>
</tr>
<tr>
<td><code>返回完成；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
</tbody></table>
<p>清单 2-6 显示了的<code>start</code>方法<code>MyOperation</code>。此方法的实现是最少的，以便演示您绝对必须执行的任务。在这种情况下，该方法仅启动一个新线程并将其配置为调用该<code>main</code>方法。该方法还更新<code>executing</code>成员变量并为<code>isExecuting</code>键路径生成 KVO 通知以反映该值的更改。完成工作后，此方法将简单地返回，保留新分离的线程来执行实际任务。</p>
<p><strong>清单 2-6</strong> start 方法</p>
<table>
<thead>
<tr>
<th><code>-（void）开始{</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>//在启动任务之前，请务必检查是否取消。</code></td>
</tr>
<tr>
<td><code>如果（[self isCancelled]）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>//如果取消操作，则必须将操作移至完成状态。</code></td>
</tr>
<tr>
<td><code>[self willChangeValueForKey：@“ isFinished”]；</code></td>
</tr>
<tr>
<td><code>完成=是；</code></td>
</tr>
<tr>
<td><code>[self didChangeValueForKey：@“ isFinished”]；</code></td>
</tr>
<tr>
<td><code>返回;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//如果未取消操作，则开始执行任务。</code></td>
</tr>
<tr>
<td><code>[self willChangeValueForKey：@“ isExecuting”];</code></td>
</tr>
<tr>
<td><code>[NSThread detachNewThreadSelector：@selector（main）toTarget：self withObject：nil];</code></td>
</tr>
<tr>
<td><code>执行=是;</code></td>
</tr>
<tr>
<td><code>[self didChangeValueForKey：@“ isExecuting”];</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>清单 2-7 显示了<code>MyOperation</code>该类的其余实现。如<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW11" target="_blank" rel="noopener">清单 2-6 所示</a>，该<code>main</code>方法是新线程的入口点。它执行与操作对象关联的工作，并在<code>completeOperation</code>最终完成该工作时调用自定义方法。<code>completeOperation</code>然后，该方法为<code>isExecuting</code>和<code>isFinished</code>路径生成所需的 KVO 通知，以反映操作状态的变化。</p>
<p><strong>清单 2-7</strong> 在完成时更新操作</p>
<table>
<thead>
<tr>
<th><code>-（void）main {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>@尝试{</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在此执行操作的主要工作。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[自我完成操作];</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>@catch（...）{</code></td>
</tr>
<tr>
<td><code>//不要抛出异常。</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（void）completeOperation {</code></td>
</tr>
<tr>
<td><code>[self willChangeValueForKey：@“ isFinished”]；</code></td>
</tr>
<tr>
<td><code>[self willChangeValueForKey：@“ isExecuting”];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>执行=否;</code></td>
</tr>
<tr>
<td><code>完成=是；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[self didChangeValueForKey：@“ isExecuting”];</code></td>
</tr>
<tr>
<td><code>[self didChangeValueForKey：@“ isFinished”]；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>即使取消了操作，也应始终通知 KVO 观察者您的操作现已完成。当一个操作对象依赖于其他操作对象的完成时，它将监视<code>isFinished</code>那些对象的键路径。仅当所有对象都报告它们完成时，相关操作才会发出信号，表明它已准备好运行。因此，无法生成完成通知可能会阻止应用程序中其他操作的执行。</p>
<h6 id="保持-KVO-合规性"><a href="#保持-KVO-合规性" class="headerlink" title="保持 KVO 合规性"></a>保持 KVO 合规性</h6><p>的<code>NSOperation</code>类是键-值观察（KVO）兼容以下关键路径：</p>
<ul>
<li><code>isCancelled</code></li>
<li><code>isConcurrent</code></li>
<li><code>isExecuting</code></li>
<li><code>isFinished</code></li>
<li><code>isReady</code></li>
<li><code>dependencies</code></li>
<li><code>queuePriority</code></li>
<li><code>completionBlock</code></li>
</ul>
<p>如果您重写该<code>start</code>方法或对<code>NSOperation</code>对象进行任何重要的自定义（而不是 override）<code>main</code>，则必须确保您的自定义对象对这些关键路径保持 KVO 兼容。覆盖该<code>start</code>方法时，您应该最关注的关键路径是<code>isExecuting</code>和<code>isFinished</code>。这些是重新实现该方法最常影响的关键路径。</p>
<p>如果要实现对除其他操作对象之外的其他对象的依赖关系的支持，则还可以重写该<code>isReady</code>方法并强制其返回，<code>NO</code>直到满足您的自定义依赖关系为止。（如果实现自定义依赖项，则如果仍然支持该类提供的默认依赖项管理系统，请确保<code>super</code>从<code>isReady</code>方法中调用<code>NSOperation</code>。）当操作对象的就绪状态更改时，请为<code>isReady</code>关键路径生成 KVO 通知以报告这些更改。除非您重写<code>addDependency:</code>or <code>removeDependency:</code>方法，否则您不必担心会为<code>dependencies</code>密钥路径生成 KVO 通知。</p>
<p>尽管您可以为的其他关键路径生成 KVO 通知<code>NSOperation</code>，但您不太可能需要这样做。如果您需要取消操作，则只需调用现有<code>cancel</code>方法即可。同样，您几乎不需要修改操作对象中的队列优先级信息。最后，除非您的操作能够动态更改其并发状态，否则您不需要为<code>isConcurrent</code>密钥路径提供 KVO 通知。</p>
<p>有关键值观察以及如何在自定义对象中支持键值的更多信息，请参见《_<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="noopener">键值观察编程指南》</a>_。</p>
<h4 id="自定义操作对象的执行行为"><a href="#自定义操作对象的执行行为" class="headerlink" title="自定义操作对象的执行行为"></a>自定义操作对象的执行行为</h4><p>操作对象的配置在创建对象之后但将它们添加到队列之前进行。本节中描述的配置类型可以应用于所有操作对象，而不管您是<code>NSOperation</code>自己继承还是使用现有的子类。</p>
<h6 id="配置互操作依赖性"><a href="#配置互操作依赖性" class="headerlink" title="配置互操作依赖性"></a>配置互操作依赖性</h6><p>依赖关系是您序列化不同操作对象的执行的一种方法。依赖于其他操作的操作要等到它所依赖的所有操作完成执行后才能开始执行。因此，您可以使用依赖关系在两个操作对象之间创建简单的一对一依赖关系或构建复杂的对象依赖关系图。</p>
<p>要建立两个操作对象之间的依赖关系，请使用的<code>addDependency:</code>方法<code>NSOperation</code>。此方法创建从当前操作对象到您指定为参数的目标操作的单向依赖关系。这种依赖性意味着在目标对象完成执行之前，当前对象无法开始执行。依赖关系也不限于同一队列中的操作。操作对象管理它们自己的依赖关系，因此完全可以在操作之间创建依赖关系并将它们全部添加到不同的队列中。但是，不可接受的一件事是在操作之间创建循环依赖关系。这样做是程序员的错误，它将阻止受影响的操作运行。</p>
<p>当所有操作的依赖项本身都已完成执行时，操作对象通常可以执行。（如果自定义<code>isReady</code>方法的行为，则操作的就绪状态由您设置的条件决定。）如果操作对象在队列中，则该队列可随时开始执行该操作。如果您打算手动执行该操作，则取决于您调用该操作的<code>start</code>方法。</p>
<p><strong>要点：</strong> 在运行操作或将它们添加到操作队列之前，应始终配置依赖关系。之后添加的依赖关系可能不会阻止给定的操作对象运行。</p>
<p>依赖关系依赖于每一个操作对象每当对象状态发生变化时就发出适当的 KVO 通知。如果自定义操作对象的行为，则可能需要从自定义代码生成适当的 KVO 通知，以避免引起依赖关系问题。有关 KVO 通知和操作对象的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW10" target="_blank" rel="noopener">维护 KVO 合规性</a>。有关配置依赖项的其他信息，请参见《_<a href="https://developer.apple.com/documentation/foundation/nsoperation" target="_blank" rel="noopener">NSOperation 类参考》</a>_。</p>
<h6 id="更改工序的执行优先级"><a href="#更改工序的执行优先级" class="headerlink" title="更改工序的执行优先级"></a>更改工序的执行优先级</h6><p>对于添加到队列中的操作，执行顺序首先由排队的操作的就绪状态确定，然后由其相对优先级确定。就绪状态由操作对其他操作的依赖关系确定，但是优先级是操作对象本身的属性。默认情况下，所有新操作对象都具有“普通”优先级，但是您可以根据需要通过调用对象的<code>setQueuePriority:</code>方法来增加或减少该优先级。</p>
<p>优先级仅适用于同一操作队列中的操作。如果您的应用程序具有多个操作队列，则每个队列都将独立于其他队列的优先级分配给自己的操作。因此，低优先级操作仍然有可能在不同队列中先于高优先级操作执行。</p>
<p>优先级不能替代依赖关系。优先级确定操作队列开始仅执行当前准备就绪的那些操作的顺序。例如，如果队列同时包含高优先级和低优先级操作，并且两个操作都准备就绪，则该队列首先执行高优先级操作。但是，如果高优先级操作尚未准备就绪，但低优先级操作已就绪，则队列首先执行低优先级操作。如果要阻止一个操作在另一个操作完成之前开始，则必须使用依赖项（如<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17" target="_blank" rel="noopener">配置互操作依赖项中所述</a>）。</p>
<h6 id="更改底层线程优先级"><a href="#更改底层线程优先级" class="headerlink" title="更改底层线程优先级"></a>更改底层线程优先级</h6><p>在 OS X v10.6 和更高版本中，可以配置操作的基础线程的执行优先级。系统中的线程策略本身由内核管理，但通常，优先级较高的线程比低优先级的线程有更多的运行机会。在操作对象中，将线程优先级指定为 0.0 到 1.0 范围内的浮点值，其中 0.0 是最低优先级，而 1.0 是最高优先级。如果未指定显式线程优先级，则该操作将以默认线程优先级 0.5 运行。</p>
<p>若要设置操作的线程优先级，必须先将<code>setThreadPriority:</code>操作对象的方法添加到队列中（或手动执行），然后再调用该方法。当需要执行该操作时，默认<code>start</code>方法将使用您指定的值来修改当前线程的优先级。此新优先级<code>main</code>仅在您的操作方法期间有效。所有其他代码（包括操作的完成块）均以默认线程优先级运行。如果创建并发操作并因此覆盖该<code>start</code>方法，则必须自己配置线程优先级。</p>
<h6 id="设定完成区块"><a href="#设定完成区块" class="headerlink" title="设定完成区块"></a>设定完成区块</h6><p>在 OS X v10.6 和更高版本中，某个操作可以在其主要任务完成执行时执行完成块。您可以使用完成块来执行任何不属于主要任务的工作。例如，您可以使用此块来通知感兴趣的客户端操作本身已完成。并发操作对象可能使用此块来生成其最终的 KVO 通知。</p>
<p>要设置完成块，请使用的<code>setCompletionBlock:</code>方法<code>NSOperation</code>。传递给此方法的块应该没有参数，也没有返回值。</p>
<h4 id="实施操作对象的技巧"><a href="#实施操作对象的技巧" class="headerlink" title="实施操作对象的技巧"></a>实施操作对象的技巧</h4><p>尽管操作对象相当容易实现，但是在编写代码时，您应该注意几件事。以下各节描述了为操作对象编写代码时应考虑的因素。</p>
<h6 id="管理操作对象中的内存"><a href="#管理操作对象中的内存" class="headerlink" title="管理操作对象中的内存"></a>管理操作对象中的内存</h6><p>以下各节描述了操作对象中良好的内存管理的关键元素。有关 Objective-C 程序中的内存管理的一般信息，请参阅《_<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">高级内存管理编程指南》</a>_。</p>
<p>######## 避免按线程存储</p>
<p>尽管大多数操作在线程上执行，但在非并行操作的情况下，该线程通常由操作队列提供。如果操作队列为您提供了一个线程，则应考虑该线程归队列所有，而不应被您的操作触及。特别是，您永远不要将任何数据与您自己创建或管理的线程无关。由操作队列管理的线程来来往往取决于系统和应用程序的需求。因此，使用每线程存储在操作之间传递数据是不可靠的，并且很可能失败。</p>
<p>对于操作对象，无论如何都没有理由使用每线程存储。初始化操作对象时，应为该对象提供完成其工作所需的一切。因此，操作对象本身提供了所需的上下文存储。所有传入和传出的数据都应存储在此处，直到可以将其重新集成到您的应用程序中或不再需要为止。</p>
<p>######## 根据需要保留对操作对象的引用</p>
<p>仅仅因为操作对象是异步运行的，您不应该假设您可以创建它们而忘记它们。它们仍然只是对象，您需要管理代码需要的对它们的任何引用。如果您需要在操作完成后从结果数据中检索结果，这尤其重要。</p>
<p>您应该始终保留自己对操作的引用的原因是，您以后可能没有机会向该队列询问对象。队列尽一切努力尽快分配和执行操作。在许多情况下，队列在添加后几乎立即开始执行操作。等到您自己的代码返回队列以获取对该操作的引用时，该操作可能已经完成并从队列中删除。</p>
<h6 id="处理错误和异常"><a href="#处理错误和异常" class="headerlink" title="处理错误和异常"></a>处理错误和异常</h6><p>因为操作本质上是应用程序内部的离散实体，所以它们负责处理出现的任何错误或异常。在 OS X v10.6 和更高版本中，该类<code>start</code>提供的默认方法<code>NSOperation</code>不会捕获异常。（在 OS X v10.5 中，start 方法确实捕获和抑制异常。）您自己的代码应始终直接捕获和抑制异常。它还应检查错误代码，并根据需要通知应用程序的适当部分。并且，如果替换了该<code>start</code>方法，则必须类似地在自定义实现中捕获任何异常，以防止它们离开基础线程的范围。</p>
<p>在错误情况类型中，您应该准备处理以下几种：</p>
<ul>
<li>检查并处理 UNIX <code>errno</code>风格的错误代码。</li>
<li>检查方法和函数返回的显式错误代码。</li>
<li>捕获由您自己的代码或其他系统框架引发的异常。</li>
<li>捕获由<code>NSOperation</code>类本身引发的异常，在以下情况下会引发异常：<ul>
<li>当操作尚未准备好执行但其<code>start</code>方法被调用时</li>
<li>当操作正在执行或完成时（可能是因为已取消），并且<code>start</code>再次调用了其方法</li>
<li>当您尝试将完成块添加到已执行或已完成的操作中时</li>
<li>当您尝试检索<code>NSInvocationOperation</code>已取消对象的结果时</li>
</ul>
</li>
</ul>
<p>如果您的自定义代码确实遇到异常或错误，则应采取所需的任何步骤将该错误传播到应用程序的其余部分。本<code>NSOperation</code>类不沿着错误的结果代码或例外传递给你的应用程序的其他部分提供了明确的方法。因此，如果此类信息对您的应用程序很重要，则必须提供必要的代码。</p>
<h4 id="确定操作对象的适当范围"><a href="#确定操作对象的适当范围" class="headerlink" title="确定操作对象的适当范围"></a>确定操作对象的适当范围</h4><p>尽管可以向操作队列中添加任意数量的操作，但是这样做通常是不切实际的。像任何对象一样，<code>NSOperation</code>该类的实例会消耗内存，并具有与其执行相关的实际成本。如果每个操作对象仅执行少量工作，并且创建了数以万计的对象，则可能会发现与实际工作相比，您花费的时间更多。而且，如果您的应用程序已经受到内存的限制，您可能会发现，在内存中只有成千上万个操作对象可能会进一步降低性能。</p>
<p>有效使用操作的关键是在需要做的工作量和保持计算机忙之间找到适当的平衡。尝试确保您的操作完成了合理的工作量。例如，如果您的应用程序创建了 100 个操作对象以对 100 个不同的值执行相同的任务，请考虑创建 10 个操作对象以分别处理 10 个值。</p>
<p>您还应该避免一次将大量操作添加到队列中，或者避免将操作对象连续添加到队列中的速度比处理对象快。而不是用操作对象填充队列，而是分批创建这些对象。当一个批处理完成执行时，请使用完成块告诉您的应用程序创建一个新的批处理。当您有很多工作要做时，您希望使队列中充满足够的操作，以使计算机保持繁忙状态，但是您不想一次创建太多的操作，而导致应用程序内存不足。</p>
<p>当然，您创建的操作对象的数量以及在每个对象中执行的工作量是可变的，并且完全取决于您的应用程序。您应该始终使用仪器之类的工具来帮助您在效率和速度之间找到适当的平衡。有关可用于收集代码指标的工具和其他性能工具的<em><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" target="_blank" rel="noopener">概述</a>*，请参见</em><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" target="_blank" rel="noopener">性能概述</a>*。</p>
<h4 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h4><p>最终，您的应用程序需要执行操作才能完成关联的工作。在本节中，您将学习几种执行操作的方法，以及如何在运行时操纵操作的执行。</p>
<h6 id="将操作添加到操作队列"><a href="#将操作添加到操作队列" class="headerlink" title="将操作添加到操作队列"></a>将操作添加到操作队列</h6><p>到目前为止，执行操作的最简单方法是使用操作队列，它是<code>NSOperationQueue</code>类的实例。您的应用程序负责创建和维护打算使用的任何操作队列。一个应用程序可以有任意数量的队列，但是在给定的时间点可能要执行多少操作有实际的限制。操作队列与系统一起使用，以将并发操作的数量限制为适合于可用核心和系统负载的值。因此，创建其他队列并不意味着您可以执行其他操作。</p>
<p>要创建队列，可以像在任何其他对象中一样在应用程序中分配它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue * aQueue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>

<p>要将操作添加到队列，请使用<code>addOperation:</code>方法。在 OS X v10.6 和更高版本中，您可以使用<code>addOperations:waitUntilFinished:</code>方法添加操作组，也可以使用以下方法将块对象直接添加到队列中（没有相应的操作对象）<code>addOperationWithBlock:</code>方法。这些方法中的每一个都将一个操作（或多个操作）排队，并通知队列它应该开始处理它们。在大多数情况下，操作会在添加到队列后立即执行，但是由于多种原因，操作队列可能会延迟排队操作的执行。具体来说，如果排队的操作依赖于尚未完成的其他操作，则执行可能会延迟。如果操作队列本身被挂起或已经在执行其最大数量的并发操作，则执行也可能会延迟。以下示例显示了将操作添加到队列的基本语法。</p>
<table>
<thead>
<tr>
<th><code>[aQueue addOperation：anOp]; //添加一个操作</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>[aQueue addOperations：anArrayOfOps waitUntilFinished：NO]；//添加多个操作</code></td>
</tr>
<tr>
<td><code>[aQueue addOperationWithBlock：^ {</code></td>
</tr>
<tr>
<td><code>/* 做一点事。* /</code></td>
</tr>
<tr>
<td><code>}];</code></td>
</tr>
</tbody></table>
<p><strong>重要：</strong></p>
<p>在将操作对象添加到队列之前，应该对其进行所有必要的配置和修改，因为一旦添加了操作对象，该操作就可以在任何时间运行，对于进行更改以达到预期效果而言可能为时已晚。</p>
<p>尽管<code>NSOperationQueue</code>该类是为同时执行操作而设计的，但是可以强制单个队列一次仅运行一个操作。的<code>setMaxConcurrentOperationCount:</code>方法可让您配置操作队列对象的最大并发操作数。将值 1 传递给此方法将导致队列一次仅执行一个操作。尽管一次只能执行一个操作，但是执行的顺序仍然基于其他因素，例如每个操作的就绪性及其分配的优先级。因此，串行化操作队列所提供的行为与 Grand Central Dispatch 中的串行调度队列所提供的行为完全不同。如果操作对象的执行顺序对您很重要，则应在将操作添加到队列之前使用依赖关系来建立顺序。有关配置依赖关系的信息，请参阅《<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17" target="_blank" rel="noopener">配置互操作依赖关系》</a>。</p>
<p>有关使用操作队列的信息，请参见*<a href="https://developer.apple.com/documentation/foundation/nsoperationqueue" target="_blank" rel="noopener">NSOperationQueue 类参考</a>*。有关串行调度队列的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW6" target="_blank" rel="noopener">创建串行调度队列</a>。</p>
<h6 id="手动执行操作"><a href="#手动执行操作" class="headerlink" title="手动执行操作"></a>手动执行操作</h6><p>尽管操作队列是运行操作对象的最方便的方法，但是也可以在没有队列的情况下执行操作。但是，如果选择手动执行操作，则应在代码中采取一些预防措施。特别是，该操作必须准备就绪可以运行，并且您必须始终使用其<code>start</code>方法启动它。</p>
<p>直到操作的<code>isReady</code>方法返回后，才认为该操作可以运行<code>YES</code>。该<code>isReady</code>方法被集成到<code>NSOperation</code>该类的依赖管理系统中，以提供操作的依赖状态。只有清除了其依赖性后，才可以开始执行操作。</p>
<p>手动执行操作时，应始终使用该<code>start</code>方法开始执行。您使用此方法，而不是<code>main</code>其他方法，因为该<code>start</code>方法在实际运行您的自定义代码之前会执行多项安全检查。特别是，默认<code>start</code>方法会生成操作正确处理其依赖关系所需的 KVO 通知。如果该操作已被取消，则此方法还可以正确避免执行该操作，并且如果您的操作实际上尚未准备好运行，则该方法将引发异常。</p>
<p>如果您的应用程序定义了并发操作对象，则还应该考虑<code>isConcurrent</code>在启动它们之前调用操作方法。在此方法返回的情况下<code>NO</code>，您的本地代码可以决定是在当前线程中同步执行操作还是首先创建单独的线程。但是，实施这种检查完全取决于您。</p>
<p>清单 2-8 显示了在手动执行操作之前应执行的检查类型的简单示例。如果该方法返回<code>NO</code>，则可以安排一个计时器，稍后再调用该方法。然后，您将继续重新安排计时器的时间，直到方法返回<code>YES</code>，这可能是由于操作被取消而发生的。</p>
<p><strong>清单 2-8</strong> 手动执行操作对象</p>
<table>
<thead>
<tr>
<th><code>-（BOOL）performOperation：（NSOperation *）anOp</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>BOOL ranIt = NO;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（[anOp isReady] &amp;&amp;！[anOp isCancelled]）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>如果（！[anOp isConcurrent]）</code></td>
</tr>
<tr>
<td><code>[anOp开始]；</code></td>
</tr>
<tr>
<td><code>其他</code></td>
</tr>
<tr>
<td><code>[NSThread detachNewThreadSelector：@selector（开始）</code></td>
</tr>
<tr>
<td><code>toTarget：anOp withObject：nil];</code></td>
</tr>
<tr>
<td><code>ranIt =是；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>否则，如果（[anOp isCancelled]）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>//如果在开始之前已将其取消，</code></td>
</tr>
<tr>
<td><code>//将操作移至完成状态。</code></td>
</tr>
<tr>
<td><code>[self willChangeValueForKey：@“ isFinished”]；</code></td>
</tr>
<tr>
<td><code>[self willChangeValueForKey：@“ isExecuting”];</code></td>
</tr>
<tr>
<td><code>执行=否;</code></td>
</tr>
<tr>
<td><code>完成=是；</code></td>
</tr>
<tr>
<td><code>[self didChangeValueForKey：@“ isExecuting”];</code></td>
</tr>
<tr>
<td><code>[self didChangeValueForKey：@“ isFinished”]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将ranIt设置为YES，以防止操作</code></td>
</tr>
<tr>
<td><code>//将来再次传递给此方法。</code></td>
</tr>
<tr>
<td><code>ranIt =是；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>返回ranIt;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<h6 id="取消操作"><a href="#取消操作" class="headerlink" title="取消操作"></a>取消操作</h6><p>一旦添加到操作队列中，操作对象将有效地归队列所有，并且无法删除。使操作出队的唯一方法是取消操作。您可以通过调用单个操作对象的<code>cancel</code>方法来取消它，也可以通过调用<code>cancelAllOperations</code>队列对象的方法来取消队列中的所有操作对象。</p>
<p>仅当确定不再需要操作时，才应取消操作。发出取消命令会将操作对象置于“已取消”状态，这将阻止其运行。由于取消的操作仍被认为是“完成”的，因此依赖于该操作的对象将收到适当的 KVO 通知以清除该依赖关系。因此，更常见的是响应某些重大事件来取消所有排队的操作，例如应用程序退出或用户明确要求取消，而不是有选择地取消操作。</p>
<h6 id="等待操作完成"><a href="#等待操作完成" class="headerlink" title="等待操作完成"></a>等待操作完成</h6><p>为了获得最佳性能，您应将操作设计为尽可能异步，使应用程序在执行操作时可以自由执行其他工作。如果创建操作的代码也处理该操作的结果，则可以使用<code>waitUntilFinished</code>方法<code>NSOperation</code>来阻止该代码，直到操作完成。但是，通常，如果可以帮助，最好避免调用此方法。阻塞当前线程可能是一个方便的解决方案，但是它的确在代码中引入了更多的序列化，并限制了并发的总量。</p>
<p><strong>重要：</strong> 永远不要等待应用程序主线程中的操作。您只能从辅助线程或其他操作中执行此操作。阻塞主线程会阻止您的应用程序响应用户事件，并可能使您的应用程序显示为无响应。</p>
<p>除了等待单个操作完成之外，您还可以通过调用的<code>waitUntilAllOperationsAreFinished</code>方法来等待队列中的所有操作<code>NSOperationQueue</code>。等待整个队列结束时，请注意您的应用程序的其他线程仍可以向队列添加操作，从而延长了等待时间。</p>
<h6 id="挂起和恢复队列"><a href="#挂起和恢复队列" class="headerlink" title="挂起和恢复队列"></a>挂起和恢复队列</h6><p>如果要暂时停止操作的执行，则可以使用<code>setSuspended:</code>方法暂停相应的操作队列。暂停队列不会导致已经执行的操作在其任务中间暂停。它只是防止新操作被安排执行。您可能会暂停队列以响应用户暂停任何正在进行的工作的请求，因为期望用户最终可能希望恢复该工作。</p>
<h2 id="调度队列-1"><a href="#调度队列-1" class="headerlink" title="调度队列"></a>调度队列</h2><p>大中央调度（GCD）调度队列是执行任务的强大工具。调度队列使您可以相对于调用者异步或同步执行任意代码块。您可以使用调度队列来执行几乎在单独的线程上执行过的所有任务。调度队列的优点是，与相应的线程代码相比，它们更易于使用并且在执行这些任务时效率更高。</p>
<p>本章介绍了分派队列，以及有关如何在应用程序中使用它们执行常规任务的信息。如果要用调度队列替换现有的线程代码，可以在<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1" target="_blank" rel="noopener">《从线程迁移》中</a>找到一些其他技巧。</p>
<h4 id="关于调度队列"><a href="#关于调度队列" class="headerlink" title="关于调度队列"></a>关于调度队列</h4><p>调度队列是在应用程序中异步并发执行任务的简便方法。一个<em>任务</em>很简单，就是你的应用程序需要执行一些工作。例如，您可以定义任务来执行一些计算，创建或修改数据结构，处理从文件中读取的某些数据或任何其他事物。通过将相应的代码放在函数或块对象内并将其添加到调度队列中，可以定义任务。</p>
<p>调度队列是一个类似对象的结构，用于管理您提交给它的任务。所有调度队列均为先进先出数据结构。因此，添加到队列中的任务始终以与添加任务相同的顺序启动。GCD 自动为您提供了一些调度队列，但您可以为特定目的创建其他调度队列。表 3-1 列出了可用于您的应用程序的调度队列的类型以及如何使用它们。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">序列号</td>
<td align="left">串行队列（也称为<em>专用调度队列</em>）按添加到队列的顺序一次执行一个任务。当前执行的任务在分派队列管理的不同线程（随任务的不同而不同）上运行。串行队列通常用于同步对特定资源的访问。您可以根据需要创建任意数量的串行队列，并且每个队列相对于所有其他队列可以同时运行。换句话说，如果创建四个串行队列，则每个队列一次只能执行一个任务，但是最多仍可以同时执行四个任务，每个队列一个。有关如何创建串行队列的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW6" target="_blank" rel="noopener">创建串行调度队列</a>。</td>
</tr>
<tr>
<td align="left">同时</td>
<td align="left">并发队列（也称为<em>全局调度队列的一种</em>）可以并发执行一个或多个任务，但是任务仍然按照它们添加到队列中的顺序启动。当前执行的任务在分派队列管理的不同线程上运行。在任何给定点执行的任务的确切数量是可变的，并且取决于系统条件。在 iOS 5 及更高版本中，您可以通过指定<code>DISPATCH_QUEUE_CONCURRENT</code>作为队列类型来自己创建并发调度队列。另外，有四个预定义的全局并发队列供您的应用程序使用。有关如何获取全局并发队列的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5" target="_blank" rel="noopener">获取全局并发调度队列</a>。</td>
</tr>
<tr>
<td align="left">主调度队列</td>
<td align="left">主调度队列是全局可用的串行队列，可在应用程序的主线程上执行任务。该队列与应用程序的运行循环（如果存在）一起工作，以使排队任务的执行与附加到运行循环的其他事件源的执行交织在一起。因为它在应用程序的主线程上运行，所以通常将其用作应用程序的关键同步点。尽管您无需创建主调度队列，但仍需要确保应用程序适当地耗尽它。有关如何管理此队列的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW15" target="_blank" rel="noopener">在主线程上执行任务</a>。</td>
</tr>
</tbody></table>
<p>当涉及到向应用程序添加并发时，分派队列提供了一些优于线程的优点。最直接的好处是工作队列编程模型的简单性。使用线程，您必须为要执行的工作以及线程本身的创建和管理编写代码。调度队列使您可以专注于实际要执行的工作，而不必担心线程的创建和管理。而是由系统为您处理所有线程的创建和管理。优点是该系统比任何单个应用程序都能够更有效地管理线程。系统可以根据可用资源和当前系统状况动态扩展线程数量。此外，</p>
<p>尽管您可能认为很难为调度队列重写代码，但是为调度队列编写代码通常比为线程编写代码容易。编写代码的关键是设计独立且能够异步运行的任务。（实际上，这对于线程和调度队列都是正确的。）但是，调度队列具有优势的是可预测性。如果您有两个任务访问相同的共享资源但在不同的线程上运行，则每个线程都可以首先修改资源，并且您需要使用锁来确保这两个任务不会同时修改该资源。使用调度队列，您可以将两个任务都添加到串行调度队列中，以确保在任何给定时间只有一个任务修改了资源。</p>
<p>尽管您可能正确地指出了在串行队列中运行的两个任务不能同时运行，但是您必须记住，如果两个线程同时进行锁定，则线程提供的任何并发性都会丢失或显着减少。更重要的是，线程模型需要创建两个线程，这两个线程同时占用内核和用户空间内存。调度队列不会为它们的线程支付相同的内存损失，并且它们使用的线程将保持繁忙并且不会被阻塞。</p>
<p>关于调度队列，需要记住的其他一些关键点包括：</p>
<ul>
<li>调度队列相对于其他调度队列同时执行其任务。任务的序列化仅限于单个调度队列中的任务。</li>
<li>系统确定任何一次执行的任务总数。因此，在 100 个不同的队列中具有 100 个任务的应用程序可能不会并发执行所有这些任务（除非它具有 100 个或更多个有效内核）。</li>
<li>选择要启动的新任务时，系统会考虑队列优先级。有关如何设置串行队列的优先级的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW7" target="_blank" rel="noopener">为</a>队列<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW7" target="_blank" rel="noopener">提供清理功能</a>。</li>
<li>队列中的任务在添加到队列时必须准备就绪才能执行。（如果您以前使用过 Cocoa 操作对象，请注意，此行为不同于模型操作使用的行为。）</li>
<li>专用调度队列是引用计数的对象。请注意，除了将队列保留在您自己的代码中之外，还可以将调度源附加到队列并增加其保留计数。因此，您必须确保取消所有调度源，并通过适当的释放调用平衡所有保留调用。有关保留和释放队列的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW11" target="_blank" rel="noopener">调度队列的内存管理</a>。有关调度源的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW12" target="_blank" rel="noopener">关于调度源</a>。</li>
</ul>
<p>有关用于操作调度队列的接口的更多信息，请参见<em>Grand Central Dispatch（GCD）参考</em>。</p>
<h4 id="队列相关技术"><a href="#队列相关技术" class="headerlink" title="队列相关技术"></a>队列相关技术</h4><p>除了调度队列，Grand Central Dispatch 还提供了几种使用队列的技术来帮助您管理代码。表 3-2 列出了这些技术，并提供了指向您可以找到有关它们的更多信息的链接。</p>
<table>
<thead>
<tr>
<th align="left">技术</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">派遣组</td>
<td align="left">调度组是一种监视一组块对象是否完成的方法。（您可以根据需要同步或异步监视这些块。）组为依赖于其他任务完成的代码提供了一种有用的同步机制。有关使用组的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW25" target="_blank" rel="noopener">等待队列中的任务组</a>。</td>
</tr>
<tr>
<td align="left">调度信号量</td>
<td align="left">调度信号量与传统信号量相似，但通常更为有效。仅当由于信号量不可用而需要阻塞调用线程时，调度信号量才调用内核。如果信号灯可用，则不进行内核调用。有关如何使用调度信号量的示例，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24" target="_blank" rel="noopener">使用调度信号量来调节有限资源的使用</a>。</td>
</tr>
<tr>
<td align="left">派遣来源</td>
<td align="left">调度源响应于特定类型的系统事件而生成通知。您可以使用调度源来监视事件，例如流程通知，信号和描述符事件。发生事件时，调度源将您的任务代码异步提交到指定的调度队列进行处理。有关创建和使用调度源的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">调度源</a>。</td>
</tr>
</tbody></table>
<h4 id="使用块实现任务"><a href="#使用块实现任务" class="headerlink" title="使用块实现任务"></a>使用块实现任务</h4><p>块对象是一种基于 C 的语言功能，可以在 C， Objective-C 和 C ++代码中使用。块使定义一个独立的工作单元变得容易。尽管它们看起来类似于函数指针，但实际上是由类似于对象的基础数据结构表示一个块，并由编译器为您创建和管理该块。编译器打包您提供的代码（以及所有相关数据），并将其封装为可存在于堆中并在应用程序中传递的形式。</p>
<p>块的主要优点之一是它们能够使用其词法范围之外的变量。当您在函数或方法中定义一个块时，该块在某些方面可以充当传统代码块。例如，一个块可以读取在父作用域中定义的变量的值。块访问的变量被复制到堆上的块数据结构中，以便块稍后可以访问它们。将块添加到调度队列时，通常必须将这些值保留为只读格式。但是，同步执行的块也可以使用带有<code>__block</code>关键字前缀的变量，以将数据返回到父级的调用范围。</p>
<p>您可以使用类似于函数指针的语法来声明与代码内联的块。块和函数指针之间的主要区别在于，块名前面带有脱字符号（<code>^</code>）而不是星号（<code>*</code>）。像函数指针一样，您可以将参数传递给块并从中接收返回值。清单 3-1 显示了如何在代码中同步声明和执行块。该变量<code>aBlock</code>声明为采用单个整数参数且不返回任何值的块。然后将与该原型匹配的实际块分配给<code>aBlock</code>并声明为内联。最后一行立即执行该块，将指定的整数打印到标准输出中。</p>
<p><strong>清单 3-1</strong> 一个简单的块示例</p>
<table>
<thead>
<tr>
<th><code>int x = 123;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>整数y = 456;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//块声明和赋值</code></td>
</tr>
<tr>
<td><code>无效（^ aBlock）（int）= ^（int z）{</code></td>
</tr>
<tr>
<td><code>printf（“％d％d％d \ n”，x，y，z）;</code></td>
</tr>
<tr>
<td><code>};</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//执行块</code></td>
</tr>
<tr>
<td><code>aBlock（789）; //打印：123456789</code></td>
</tr>
</tbody></table>
<p>以下是设计模块时应考虑的一些关键准则的摘要：</p>
<ul>
<li>对于计划使用分派队列异步执行的块，可以从父函数或方法中捕获标量变量并将其用于块中，这是安全的。但是，您不应尝试捕获由调用上下文分配和删除的大型结构或其他基于指针的变量。在您的块执行时，该指针引用的内存可能会消失。当然，自己分配内存（或对象）并将该内存的所有权明确移交给该块是安全的。</li>
<li>调度队列复制添加到其中的块，并在完成执行时释放块。换句话说，在将块添加到队列之前，无需显式复制块。</li>
<li>尽管在执行小任务时，队列比原始线程更有效，但是创建块并在队列上执行它们仍然有开销。如果一个块的工作量太少，则以内联方式执行它比将其分配到队列中要便宜。判断某个块是否工作量太少的方法是使用性能工具收集每个路径的指标并进行比较。</li>
<li>不要缓存相对于基础线程的数据，并希望可以从其他块访问该数据。如果同一队列中的任务需要共享数据，请改用分派队列的上下文指针存储数据。有关如何访问调度队列的上下文数据的更多信息，请参见使用队列<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="noopener">存储自定义上下文信息</a>。</li>
<li>如果您的块创建了多个 Objective-C 对象，则可能需要将部分代码的代码封装在@autorelease 块中，以处理这些对象的内存管理。尽管 GCD 调度队列具有自己的自动释放池，但它们不保证这些池何时耗尽。如果您的应用程序受内存限制，则创建自己的自动释放池可让您以更规则的时间间隔释放自动释放对象的内存。</li>
</ul>
<p>有关块的更多信息，包括如何声明和使用它们，请参见*<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">块编程主题</a>*。有关如何将块添加到调度队列中的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW20" target="_blank" rel="noopener">将任务添加到队列中</a>。</p>
<h4 id="创建和管理调度队列"><a href="#创建和管理调度队列" class="headerlink" title="创建和管理调度队列"></a>创建和管理调度队列</h4><p>在将任务添加到队列之前，必须确定要使用的队列类型以及打算如何使用它。调度队列可以串行或并行执行任务。另外，如果您对队列有特定的用途，则可以相应地配置队列属性。以下各节说明如何创建调度队列并配置它们以供使用。</p>
<h6 id="获取全局并发调度队列"><a href="#获取全局并发调度队列" class="headerlink" title="获取全局并发调度队列"></a>获取全局并发调度队列</h6><p>当您有多个可以并行运行的任务时，并发调度队列很有用。并发队列仍然是一个队列，因为它按照先进先出的顺序使任务出队。但是，并发队列可能会在其他先前任务完成之前使其他任务出队。并发队列在任何给定时刻执行的实际任务数是可变的，并且可以随着应用程序条件的变化而动态变化。许多因素会影响并发队列执行的任务数量，包括可用核心的数量，其他进程正在完成的工作量以及其他串行调度队列中任务的数量和优先级。</p>
<p>系统为每个应用程序提供四个并发调度队列。这些队列对于应用程序是全局的，仅按优先级进行区分。因为它们是全局的，所以您无需显式创建它们。相反，您可以使用<code>dispatch_get_global_queue</code>函数来请求队列之一，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t aQueue = dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</span><br></pre></td></tr></table></figure>

<p>除了获取默认的并发队列外，还可以通过将<code>DISPATCH_QUEUE_PRIORITY_HIGH</code>和<code>DISPATCH_QUEUE_PRIORITY_LOW</code>常量传递给函数来获取高优先级和低优先级级别的队列，或者通过传递常量来获取背景队列<code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>。如您所料，高优先级并发队列中的任务比默认队列和低优先级队列中的任务先执行。同样，默认队列中的任务在低优先级队列中的任务之前执行。</p>
<p><strong>注意：</strong> 该<code>dispatch_get_global_queue</code>函数的第二个参数保留给以后的扩展。现在，您应该始终通过<code>0</code>此参数。</p>
<p>尽管调度队列是引用计数的对象，但是您无需保留和释放全局并发队列。因为它们对于您的应用程序是全局的，所以将忽略对这些队列的保留和释放调用。因此，您不需要存储对这些队列的引用。<code>dispatch_get_global_queue</code>只要需要引用其中之一，就可以调用该函数。</p>
<h6 id="创建串行调度队列"><a href="#创建串行调度队列" class="headerlink" title="创建串行调度队列"></a>创建串行调度队列</h6><p>当您希望任务以特定顺序执行时，串行队列很有用。串行队列一次只执行一个任务，并且总是从队列的开头拉任务。您可以使用串行队列而不是锁来保护共享资源或可变数据结构。与锁不同，串行队列可确保任务以可预测的顺序执行。而且，只要您异步地将任务提交到串行队列，该队列就永远不会死锁。</p>
<p>与为您创建的并发队列不同，您必须显式创建和管理要使用的任何串行队列。您可以为您的应用程序创建任意数量的串行队列，但应避免创建大量串行队列，这仅仅是为了同时执行尽可能多的任务。如果要同时执行大量任务，请将其提交到全局并发队列之一。创建串行队列时，请尝试确定每个队列的用途，例如保护资源或同步应用程序的某些关键行为。</p>
<p>清单 3-2 显示了创建自定义串行队列所需的步骤。该<code>dispatch_queue_create</code>函数有两个参数：队列名称和一组队列属性。调试器和性能工具显示队列名称，以帮助您跟踪任务的执行方式。队列属性保留供将来使用，应为<code>NULL</code>。</p>
<p><strong>清单 3-2</strong> 创建一个新的串行队列</p>
<table>
<thead>
<tr>
<th><code>dispatch_queue_t队列；</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>队列= dispatch_queue_create（“ com.example.MyQueue”，NULL）;</code></td>
</tr>
</tbody></table>
<p>除了您创建的任何自定义队列之外，系统还会自动创建一个串行队列并将其绑定到应用程序的主线程。有关获取主线程队列的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW3" target="_blank" rel="noopener">在运行时获取公共队列</a>。</p>
<h6 id="在运行时获取通用队列"><a href="#在运行时获取通用队列" class="headerlink" title="在运行时获取通用队列"></a>在运行时获取通用队列</h6><p>Grand Central Dispatch 提供的功能使您可以从应用程序访问几个常见的调度队列：</p>
<ul>
<li>使用该<code>dispatch_get_current_queue</code>功能进行调试或测试当前队列的身份。从一个块对象内部调用该函数将返回该块已提交到的队列（现在大概在该队列上运行）。从块外部调用此函数将为您的应用程序返回默认的并发队列。</li>
<li>使用该<code>dispatch_get_main_queue</code>函数获取与应用程序的主线程关联的串行调度队列。此队列是为 Cocoa 应用程序以及在主线程上调用该<code>dispatch_main</code>函数或配置运行循环（使用<code>CFRunLoopRef</code>类型或<code>NSRunLoop</code>对象）的应用程序自动创建的。</li>
<li>使用该<code>dispatch_get_global_queue</code>函数获取任何共享的并发队列。有关更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5" target="_blank" rel="noopener">获取全局并发调度队列</a>。</li>
</ul>
<h6 id="调度队列的内存管理"><a href="#调度队列的内存管理" class="headerlink" title="调度队列的内存管理"></a>调度队列的内存管理</h6><p>调度队列和其他调度对象是引用计数的数据类型。创建串行调度队列时，它的初始引用计数为 1。可以使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数根据需要增加和减少引用计数。当队列的引用计数达到零时，系统异步取消分配该队列。</p>
<p>保留和释放调度对象（例如队列）很重要，以确保它们在使用时仍保留在内存中。与内存管理的 Cocoa 对象一样，一般规则是，如果计划使用传递给代码的队列，则应在使用该队列之前保留该队列，并在不再需要时释放它。这种基本模式可确保队列在您使用期间一直保留在内存中。</p>
<p><strong>注意：</strong> 您不需要保留或释放任何全局调度队列，包括并发调度队列或主调度队列。保留或释放队列的任何尝试都将被忽略。</p>
<p>即使实现垃圾收集的应用程序，您仍然必须保留并释放您的调度队列和其他调度对象。Grand Central Dispatch 不支持垃圾回收模型来回收内存。</p>
<h6 id="使用队列存储自定义上下文信息"><a href="#使用队列存储自定义上下文信息" class="headerlink" title="使用队列存储自定义上下文信息"></a>使用队列存储自定义上下文信息</h6><p>所有调度对象（包括调度队列）都允许您将自定义上下文数据与该对象相关联。要在给定对象上设置并获取此数据，请使用<code>dispatch_set_context</code>和<code>dispatch_get_context</code>函数。系统不会以任何方式使用您的自定义数据，这取决于您在适当的时间分配和取消分配数据。</p>
<p>对于队列，您可以使用上下文数据来存储指向 Objective-C 对象或其他数据结构的指针，该指针或数据结构有助于识别队列或其在代码中的预期用途。您可以使用队列的终结器函数在释放上下文数据之前从队列中取消分配（或取消关联）您的上下文数据。<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW8" target="_blank" rel="noopener">清单 3-3</a>给出了如何编写一个终结器函数来清除队列上下文数据的示例。</p>
<h6 id="提供队列的清理功能"><a href="#提供队列的清理功能" class="headerlink" title="提供队列的清理功能"></a>提供队列的清理功能</h6><p>创建串行调度队列后，可以附加终结器函数，以在释放队列时执行任何自定义清除。调度队列是引用计数的对象，您可以使用该<code>dispatch_set_finalizer_f</code>函数指定当队列的引用计数达到零时要执行的函数。您可以使用此函数清除与队列关联的上下文数据，并且仅当上下文指针不是时才调用该函数<code>NULL</code>。</p>
<p>清单 3-3 显示了一个自定义的终结器函数和一个创建队列并安装该终结器的函数。队列使用终结器功能释放存储在队列上下文指针中的数据。（从代码引用的<code>myInitializeDataContextFunction</code>和<code>myCleanUpDataContextFunction</code>函数是自定义函数，您将提供这些函数来初始化和清除数据结构本身的内容。）传递给 finalizer 函数的上下文指针包含与队列关联的数据对象。</p>
<p><strong>清单 3-3</strong> 安装队列清除功能</p>
<table>
<thead>
<tr>
<th><code>无效myFinalizerFunction（无效*上下文）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>MyDataContext * theData =（MyDataContext *）上下文;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//清理结构的内容</code></td>
</tr>
<tr>
<td><code>myCleanUpDataContextFunction（theData）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//现在释放结构本身。</code></td>
</tr>
<tr>
<td><code>免费（theData）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_queue_t createMyQueue（）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>MyDataContext *数据=（MyDataContext *）malloc（sizeof（MyDataContext））;</code></td>
</tr>
<tr>
<td><code>myInitializeDataContextFunction（data）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建队列并设置上下文数据。</code></td>
</tr>
<tr>
<td><code>dispatch_queue_t serialQueue = dispatch_queue_create（“ com.example.CriticalTaskQueue”，NULL）;</code></td>
</tr>
<tr>
<td><code>dispatch_set_context（serialQueue，data）;</code></td>
</tr>
<tr>
<td><code>dispatch_set_finalizer_f（serialQueue，＆myFinalizerFunction）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>返回serialQueue;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<h4 id="将任务添加到队列"><a href="#将任务添加到队列" class="headerlink" title="将任务添加到队列"></a>将任务添加到队列</h4><p>要执行任务，必须将其分派到适当的分派队列。您可以同步或异步分配任务，也可以单个或成组分配任务。进入队列后，鉴于队列的约束和队列中已有的任务，该队列将负责尽快执行您的任务。本节介绍了一些将任务分配到队列的技术，并介绍了每种方法的优点。</p>
<h6 id="将单个任务添加到队列"><a href="#将单个任务添加到队列" class="headerlink" title="将单个任务添加到队列"></a>将单个任务添加到队列</h6><p>有两种将任务添加到队列的方法：异步或同步。如果可能，与同步方法相比，首选使用<code>dispatch_async</code>和<code>dispatch_async_f</code>函数进行异步执行。将块对象或函数添加到队列时，无法知道该代码何时执行。结果，异步添加块或函数使您可以调度代码的执行，并继续从调用线程执行其他工作。如果您是从应用程序的主线程中调度任务的，那么这尤其重要-可能是响应某些用户事件。</p>
<p>尽管您应该尽可能异步地添加任务，但是有时仍然需要同步添加任务以防止出现竞争情况或其他同步错误。在这些情况下，可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数将任务添加到队列中。这些函数将阻止当前执行线程，直到指定任务完成执行为止。</p>
<p><strong>重要说明：</strong> 切勿在计划传递给该函数的队列中执行的任务中调用<code>dispatch_sync</code>or <code>dispatch_sync_f</code>函数。这对于保证死锁的串行队列特别重要，但对于并发队列也应避免。</p>
<p>以下示例显示如何使用基于块的变体异步和同步地调度任务：</p>
<table>
<thead>
<tr>
<th><code>dispatch_queue_t myCustomQueue;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>myCustomQueue = dispatch_queue_create（“ com.example.MyCustomQueue”，NULL）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_async（myCustomQueue，^ {</code></td>
</tr>
<tr>
<td><code>printf（“在这里做一些工作。\ n”）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>printf（“第一个块可能已经运行，也可能没有运行。\ n”）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_sync（myCustomQueue，^ {</code></td>
</tr>
<tr>
<td><code>printf（“在这里做更多的工作。\ n”）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td><code>printf（“两个块都已完成。\ n”）;</code></td>
</tr>
</tbody></table>
<h6 id="完成任务后执行补全"><a href="#完成任务后执行补全" class="headerlink" title="完成任务后执行补全"></a>完成任务后执行补全</h6><p>就其性质而言，分派到队列的任务独立于创建任务的代码运行。但是，当任务完成后，您的应用程序可能仍希望得到该事实的通知，以便可以合并结果。在传统的异步编程中，您可以使用回调机制来执行此操作，但是对于调度队列，您可以使用完成块。</p>
<p>完成块只是您在原始任务结束时分派到队列的另一段代码。调用代码通常在启动任务时将完成块作为参数提供。任务代码要做的就是在完成工作后将指定的块或函数提交到指定的队列。</p>
<p>清单 3-4 显示了使用 blocks 实现的平均函数。平均函数的最后两个参数允许调用者指定在报告结果时要使用的队列和块。在求平均值函数的值之后，它将结果传递到指定的块并将其分派到队列。为了防止过早释放队列，至关重要的是首先保留该队列，并在分派完成块后将其释放。</p>
<p><strong>清单 3-4</strong> 在任务执行后执行完成回调</p>
<table>
<thead>
<tr>
<th><code>void average_async（int * data，size_t len，</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>dispatch_queue_t队列，无效（^ block）（int））</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>//保留用户提供的队列</code></td>
</tr>
<tr>
<td><code>//确保它在完成之前不会消失</code></td>
</tr>
<tr>
<td><code>//可以调用块。</code></td>
</tr>
<tr>
<td><code>dispatch_retain（queue）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在默认的并发队列上进行工作，然后</code></td>
</tr>
<tr>
<td><code>//用结果调用用户提供的块。</code></td>
</tr>
<tr>
<td><code>dispatch_async（dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0），^ {</code></td>
</tr>
<tr>
<td><code>int avg = average（data，len）;</code></td>
</tr>
<tr>
<td><code>dispatch_async（queue，^ {block（avg）;}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//完成后释放用户提供的队列</code></td>
</tr>
<tr>
<td><code>dispatch_release（queue）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<h6 id="同时执行循环迭代"><a href="#同时执行循环迭代" class="headerlink" title="同时执行循环迭代"></a>同时执行循环迭代</h6><p>并发调度队列可能会提高性能的一个地方是您的循环执行固定数量的迭代。例如，假设您有一个<code>for</code>循环，该循环在每次循环迭代中都完成了一些工作：</p>
<table>
<thead>
<tr>
<th>`对于（i = 0; i</th>
</tr>
</thead>
<tbody><tr>
<td><code>printf（“％u \ n”，i）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>如果在每次迭代过程中执行的工作与在所有其他迭代过程中执行的工作不同，并且每个连续循环的完成顺序并不重要，则可以使用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数的调用来替换循环。这些函数为每次循环迭代将指定的块或函数提交到队列一次。因此，当调度到并发队列时，可以同时执行多个循环迭代。</p>
<p>您可以在调用<code>dispatch_apply</code>或时指定串行队列或并发队列<code>dispatch_apply_f</code>。传递并发队列使您可以同时执行多个循环迭代，这是使用这些功能的最常用方法。尽管使用串行队列是允许的，并且可以为您的代码做正确的事，但是使用这种队列与将循环保留在原处相比并没有真正的性能优势。</p>
<p><strong>重要说明：</strong> 和常规<code>for</code>循环一样，<code>dispatch_apply</code>and <code>dispatch_apply_f</code>函数直到所有循环迭代完成后才返回。因此，当从已经从队列上下文执行的代码中调用它们时，应该小心。如果您作为参数传递给函数的队列是一个串行队列，并且与执行当前代码的队列相同，则调用这些函数将使队列死锁。</p>
<p>因为它们有效地阻塞了当前线程，所以从主线程调用这些函数时也应小心，因为它们可能阻止事件处理循环及时响应事件。如果您的循环代码需要大量的处理时间，则可能需要从其他线程调用这些函数。</p>
<p>清单 3-5 显示了如何<code>for</code>用<code>dispatch_apply</code>语法替换前面的循环。传递给<code>dispatch_apply</code>函数的块必须包含一个标识当前循环迭代的参数。执行该块时，此参数的值<code>0</code>用于第一次迭代，<code>1</code>用于第二次迭代，依此类推。最后一次迭代的参数值是<code>count - 1</code>，其中<code>count</code>是迭代的总数。</p>
<p><strong>清单 3-5 同时</strong> 执行<code>for</code>循环的迭代</p>
<table>
<thead>
<tr>
<th><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_apply（count，queue，^（size_t i）{</code></td>
</tr>
<tr>
<td><code>printf（“％u \ n”，i）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
</tbody></table>
<p>您应该确保您的任务代码在每次迭代中都进行合理的工作量。与您调度到队列中的任何块或函数一样，安排该代码执行的开销。如果循环的每次迭代仅执行少量工作，则调度代码的开销可能会超过将其分派到队列可能带来的性能收益。如果在测试期间发现这是正确的，则可以使用跨步来增加每次循环迭代期间执行的工作量。通过跨步，您可以将原始循环的多个迭代组合到一个块中，并按比例减少迭代计数。例如，如果您最初执行 100 次迭代，但决定使用 4 的步幅，则现在从每个块执行 4 次循环迭代，您的迭代计数为 25。<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW2" target="_blank" rel="noopener">循环代码的改进</a>。</p>
<h6 id="在主线程上执行任务"><a href="#在主线程上执行任务" class="headerlink" title="在主线程上执行任务"></a>在主线程上执行任务</h6><p>Grand Central Dispatch 提供了一个特殊的调度队列，您可以使用该队列在应用程序的主线程上执行任务。该队列是为所有应用程序自动提供的，并由在其主线程上设置运行循环（由<code>CFRunLoopRef</code>类型或<code>NSRunLoop</code>对象管理）的任何应用程序自动耗尽。如果您不是要创建 Cocoa 应用程序，并且不想显式设置运行循环，则必须调用该<code>dispatch_main</code>函数以显式消耗主调度队列。您仍然可以将任务添加到队列中，但是如果不调用此函数，则这些任务将永远不会执行。</p>
<p>您可以通过调用该<code>dispatch_get_main_queue</code>函数来获取应用程序主线程的调度队列。添加到此队列的任务在主线程本身上串行执行。因此，您可以将此队列用作在应用程序其他部分中完成工作的同步点。</p>
<h6 id="在任务中使用-Objective-C-对象"><a href="#在任务中使用-Objective-C-对象" class="headerlink" title="在任务中使用 Objective-C 对象"></a>在任务中使用 Objective-C 对象</h6><p>GCD 为 Cocoa 内存管理技术提供了内置支持，因此您可以在提交给分派队列的块中自由使用 Objective-C 对象。每个调度队列都维护自己的自动释放池，以确保自动释放的对象在某个时刻被释放；队列不保证它们实际释放这些对象的时间。</p>
<p>如果您的应用程序受内存限制，并且您的块创建了多个自动释放的对象，则创建自己的自动释放池是确保及时释放对象的唯一方法。如果您的块创建了数百个对象，则可能要创建多个自动释放池或定期排空池。</p>
<p>有关自动释放池和 Objective-C 内存管理的更多信息，请参见《_<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">高级内存管理编程指南》</a>_。</p>
<h4 id="挂起和恢复队列-1"><a href="#挂起和恢复队列-1" class="headerlink" title="挂起和恢复队列"></a>挂起和恢复队列</h4><p>您可以通过挂起队列来阻止队列临时执行块对象。您可以使用<code>dispatch_suspend</code>函数挂起调度队列，然后使用函数来恢复它<code>dispatch_resume</code>。调用<code>dispatch_suspend</code>增加队列的挂起引用计数，调用<code>dispatch_resume</code>减少引用计数。当引用计数大于零时，队列保持挂起状态。因此，您必须平衡所有挂起的调用与匹配的恢复调用，以恢复处理块。</p>
<p><strong>重要：</strong> 挂起和恢复调用是异步的，仅在执行块之间生效。挂起队列不会导致已经执行的块停止。</p>
<h4 id="使用调度信号量来调节有限资源的使用"><a href="#使用调度信号量来调节有限资源的使用" class="headerlink" title="使用调度信号量来调节有限资源的使用"></a>使用调度信号量来调节有限资源的使用</h4><p>如果要提交给分派队列的任务访问某些有限资源，则可能要使用分派信号量来调节同时访问该资源的任务数。调度信号量的工作方式类似于常规信号量，但有一个例外。当资源可用时，获取调度信号的时间比获取传统系统信号的时间要少。这是因为对于这种特殊情况，Grand Central Dispatch 不会调用内核。它唯一调用内核的时间是当资源不可用时，系统需要停放线程，直到发信号为止。</p>
<p>使用调度信号量的语义如下：</p>
<ol>
<li>创建信号量（使用<code>dispatch_semaphore_create</code>函数）时，可以指定一个正整数，指示可用资源的数量。</li>
<li>在每个任务中，呼叫<code>dispatch_semaphore_wait</code>以等待信号量。</li>
<li>等待调用返回时，获取资源并进行工作。</li>
<li>处理完资源后，请释放该资源并通过调用该<code>dispatch_semaphore_signal</code>函数来指示信号量。</li>
</ol>
<p>有关这些步骤如何工作的示例，请考虑在系统上使用文件描述符。每个应用程序都可以使用有限数量的文件描述符。如果您有一个处理大量文件的任务，那么您不想一次打开这么多文件而导致文件描述符用尽。相反，您可以使用信号量来限制文件处理代码在任何时候使用的文件描述符的数量。您将合并到任务中的基本代码如下：</p>
<table>
<thead>
<tr>
<th><code>//创建信号量，指定初始池大小</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>dispatch_semaphore_t fd_sema = dispatch_semaphore_create（getdtablesize（）/ 2）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//等待一个免费的文件描述符</code></td>
</tr>
<tr>
<td><code>dispatch_semaphore_wait（fd_sema，DISPATCH_TIME_FOREVER）;</code></td>
</tr>
<tr>
<td><code>fd = open（“ / etc / services”，O_RDONLY）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//完成后释放文件描述符</code></td>
</tr>
<tr>
<td><code>关闭（FD）;</code></td>
</tr>
<tr>
<td><code>dispatch_semaphore_signal（fd_sema）;</code></td>
</tr>
</tbody></table>
<p>创建信号量时，请指定可用资源的数量。该值成为信号量的初始计数变量。每次您等待信号量时，该<code>dispatch_semaphore_wait</code>函数都会将变量 count 减 1。如果结果值为负，则该函数告诉内核阻塞您的线程。另一方面，该<code>dispatch_semaphore_signal</code>函数将 count 变量增加 1 以指示资源已释放。如果有任务被阻塞并等待资源，则随后其中一个将被解除阻塞并被允许执行其工作。</p>
<h4 id="等待排队的任务组"><a href="#等待排队的任务组" class="headerlink" title="等待排队的任务组"></a>等待排队的任务组</h4><p>调度组是一种阻塞线程的方法，直到一个或多个任务完成执行。您可以在所有指定任务完成之前无法取得进展的地方使用此行为。例如，在分派了多个任务以计算一些数据之后，您可以使用一个组来等待这些任务，然后在完成时处理结果。使用调度组的另一种方法是替代线程连接。您可以将相应的任务添加到调度组中，然后等待整个组，而不是启动几个子线程然后再与每个子线程联接。</p>
<p>清单 3-6 显示了建立组，向其分派任务并等待结果的基本过程。<code>dispatch_async</code>您可以使用<code>dispatch_group_async</code>函数代替使用该函数将任务调度到队列。此功能将任务与组关联，并将其排队等待执行。要等待一组任务完成，请使用该<code>dispatch_group_wait</code>函数，传入适当的组。</p>
<p><strong>清单 3-6</strong> 等待异步任务</p>
<table>
<thead>
<tr>
<th><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>dispatch_group_t组= dispatch_group_create（）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将任务添加到组</code></td>
</tr>
<tr>
<td><code>dispatch_group_async（group，queue，^ {</code></td>
</tr>
<tr>
<td><code>//一些异步工作</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在任务执行时做其他工作。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//如果无法再取得进步，</code></td>
</tr>
<tr>
<td><code>//等待组阻止当前线程。</code></td>
</tr>
<tr>
<td><code>dispatch_group_wait（group，DISPATCH_TIME_FOREVER）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//不再需要该组时，将其释放。</code></td>
</tr>
<tr>
<td><code>dispatch_release（group）;</code></td>
</tr>
</tbody></table>
<h4 id="调度队列和线程安全"><a href="#调度队列和线程安全" class="headerlink" title="调度队列和线程安全"></a>调度队列和线程安全</h4><p>在调度队列的上下文中谈论线程安全性似乎很奇怪，但是线程安全性仍然是一个相关主题。每当您在应用程序中实现并发时，您应该了解以下几点：</p>
<ul>
<li>调度队列本身是线程安全的。换句话说，您可以从系统上的任何线程将任务提交到调度队列，而无需先获取锁或同步对该队列的访问。</li>
<li>不要<code>dispatch_sync</code>从传递给函数调用的同一队列中正在执行的任务中调用函数。这样做将死锁队列。如果需要分派到当前队列，请使用<code>dispatch_async</code>函数异步进行。</li>
<li>避免从提交到调度队列的任务中获取锁定。尽管可以安全地从任务中使用锁，但是当您获取锁时，如果该锁不可用，则可能会完全阻塞串行队列。同样，对于并发队列，等待锁可能会阻止其他任务执行。如果需要同步部分代码，请使用串行分派队列而不是锁。</li>
<li>尽管您可以获得有关运行任务的基础线程的信息，但最好避免这样做。有关调度队列与线程的兼容性的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW18" target="_blank" rel="noopener">与 POSIX 线程的兼容性</a>。</li>
</ul>
<p>有关如何更改现有线程代码以使用调度队列的其他提示，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1" target="_blank" rel="noopener">《从线程迁移》</a>。</p>
<h2 id="派遣来源-1"><a href="#派遣来源-1" class="headerlink" title="派遣来源"></a>派遣来源</h2><p>每当您与基础系统进行交互时，您都必须为该任务做好准备而花费大量时间。调用内核或其他系统层涉及上下文的更改，与您自己的进程中发生的调用相比，更改成本相当高。结果，许多系统库提供了异步接口，以使您的代码可以向系统提交请求，并在处理该请求时继续执行其他工作。通过允许您提交请求并使用块和调度队列将结果报告回代码，Grand Central Dispatch 以此一般行为为基础。</p>
<h4 id="关于调度源"><a href="#关于调度源" class="headerlink" title="关于调度源"></a>关于调度源</h4><p>甲<em>调度源</em>是一个基本数据类型的坐标特定低层系统事件的处理。大中央调度支持以下类型的调度源：</p>
<ul>
<li><em>计时器调度源</em>生成定期通知。</li>
<li>UNIX 信号到达时，<em>信号分发源会</em>通知您。</li>
<li><em>描述符源会</em>通知您各种基于文件和套接字的操作，例如：<ul>
<li>当数据可供读取时</li>
<li>何时可以写入数据</li>
<li>在文件系统中删除，移动或重命名文件时</li>
<li>文件元信息更改时</li>
</ul>
</li>
<li><em>流程调度源会</em>通知您与流程相关的事件，例如：<ul>
<li>进程退出时</li>
<li>当流程发出呼叫<code>fork</code>或<code>exec</code>呼叫类型时</li>
<li>当信号传递到过程时</li>
</ul>
</li>
<li><em>Mach 端口调度源会</em>通知您与 Mach 相关的事件。</li>
<li><em>自定义调度源</em>是您定义并触发自己的源。</li>
</ul>
<p>调度源替换了通常用于处理系统相关事件的异步回调函数。配置调度源时，可以指定要监视的事件以及用于处理这些事件的调度队列和代码。您可以使用块对象或功能指定代码。当感兴趣的事件到达时，调度源将您的块或函数提交到指定的调度队列以执行。</p>
<p>与您手动提交到队列的任务不同，调度源为应用程序提供了连续的事件源。调度源将一直附加到其调度队列，直到您明确取消它为止。附加后，无论何时发生相应事件，它都会将其关联的任务代码提交到调度队列。某些事件（例如计时器事件）以固定的间隔发生，但大多数仅在特定条件出现时才偶尔发生。因此，调度源保留其关联的调度队列，以防止在事件可能仍未决时过早地将其释放。</p>
<p>为了防止事件积压在调度队列中，调度源实施事件合并方案。如果新事件到达前一个事件的事件处理程序之前已经出队并执行，则调度源将新事件数据中的数据与旧事件中的数据合并。根据事件的类型，合并可能会替换旧事件或更新其持有的信息。例如，基于信号的调度源仅提供有关最新信号的信息，而且还报告自从上次调用事件处理程序以来已传递了多少总信号。</p>
<h4 id="创建调度源"><a href="#创建调度源" class="headerlink" title="创建调度源"></a>创建调度源</h4><p>创建调度源涉及创建事件源和调度源本身。事件的来源是处理事件所需的任何本机数据结构。例如，对于基于描述符的调度源，您将需要打开描述符，而对于基于进程的源，则需要获取目标程序的进程 ID。有了事件源后，就可以按照以下方式创建相应的调度源：</p>
<ol>
<li>使用<code>dispatch_source_create</code>函数创建调度源。</li>
<li>配置调度源：<ul>
<li>将事件处理程序分配给调度源；请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW13" target="_blank" rel="noopener">编写和安装事件处理程序</a>。</li>
<li>对于计时器源，使用<code>dispatch_source_set_timer</code>功能设置计时器信息；请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW2" target="_blank" rel="noopener">创建计时器</a>。</li>
</ul>
</li>
<li>（可选）将取消处理程序分配给调度源；请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW14" target="_blank" rel="noopener">安装取消处理程序</a>。</li>
<li>调用该<code>dispatch_resume</code>函数以开始处理事件；请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW8" target="_blank" rel="noopener">暂停和恢复派遣源</a>。</li>
</ol>
<p>由于调度源在使用前需要进行一些其他配置，因此该<code>dispatch_source_create</code>函数以挂起状态返回调度源。挂起时，调度源将接收事件，但不对其进行处理。这使您有时间安装事件处理程序并执行处理实际事件所需的任何其他配置。</p>
<p>以下各节向您展示如何配置调度源的各个方面。有关显示如何配置特定类型的调度源的详细示例，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW22" target="_blank" rel="noopener">调度源示例</a>。有关用于创建和配置调度源的功能的其他信息，请参阅《_Grand Central Dispatch（GCD）参考》_。</p>
<h6 id="编写和安装事件处理程序"><a href="#编写和安装事件处理程序" class="headerlink" title="编写和安装事件处理程序"></a>编写和安装事件处理程序</h6><p>要处理由调度源生成的事件，必须定义事件处理程序以处理这些事件。事件处理程序是您使用或函数安装在调度源上的函数或块对象。当事件到达时，调度源将您的事件处理程序提交到指定的调度队列以进行处理。<code>dispatch_source_set_event_handler``dispatch_source_set_event_handler_f</code></p>
<p>事件处理程序的主体负责处理任何到达的事件。如果事件处理程序已经排队，并在新事件到达时等待处理事件，则调度源将两个事件合并。事件处理程序通常只看到有关最新事件的信息，但是根据调度源的类型，事件处理程序也可能能够获取有关发生并合并的其他事件的信息。如果在事件处理程序开始执行之后到达一个或多个新事件，则调度源将保留这些事件，直到当前事件处理程序完成执行为止。此时，它将使用新事件再次将事件处理程序提交到队列。</p>
<p>基于函数的事件处理程序采用单个上下文指针，其中包含调度源对象，并且不返回任何值。基于块的事件处理程序不带参数，也没有返回值。</p>
<table>
<thead>
<tr>
<th><code>//基于块的事件处理程序</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>无效（^ dispatch_block_t）（无效）</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//基于函数的事件处理程序</code></td>
</tr>
<tr>
<td><code>无效（* dispatch_function_t）（无效*）</code></td>
</tr>
</tbody></table>
<p>在事件处理程序内部，您可以从调度源本身获取有关给定事件的信息。尽管将基于函数的事件处理程序作为参数传递给调度源的指针，但是基于块的事件处理程序必须自己捕获该指针。您可以通过正常引用包含调度源的变量来为您的块执行此操作。例如，以下代码片段捕获了<code>source</code>在块范围之外声明的变量。</p>
<table>
<thead>
<tr>
<th><code>dispatch_source_t source = dispatch_source_create（DISPATCH_SOURCE_TYPE_READ，</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>myDescriptor，0，myQueue）；</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（source，^ {</code></td>
</tr>
<tr>
<td><code>//从捕获的源变量中获取一些数据</code></td>
</tr>
<tr>
<td><code>//来自父上下文。</code></td>
</tr>
<tr>
<td><code>估计的size_t = dispatch_source_get_data（source）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//继续阅读描述符...</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td><code>dispatch_resume（源）;</code></td>
</tr>
</tbody></table>
<p>通常会在块内部捕获变量，以实现更大的灵活性和动态性。当然，默认情况下，捕获的变量在块内是只读的。尽管块功能提供了在特定情况下修改捕获的变量的支持，但您不应在与分派源关联的事件处理程序中尝试这样做。调度源始终异步执行其事件处理程序，因此捕获的所有变量的定义范围可能在事件处理程序执行时就消失了。有关如何在块内捕获和使用变量的更多信息，请参见*<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">块编程主题</a>*。</p>
<p>表 4-1 列出了可以从事件处理程序代码中调用以获取有关事件的信息的功能。</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>dispatch_source_get_handle</code></td>
<td align="left">此函数返回调度源管理的基础系统数据类型。对于描述符调度源，此函数返回一个<code>int</code>包含与调度源关联的描述符的类型。对于信号分配源，此函数返回一个<code>int</code>类型，该类型包含最近事件的信号编号。对于流程调度源，此函数返回<code>pid_t</code>要监视的流程的数据结构。对于马赫端口分配源，此函数返回<code>mach_port_t</code>数据结构。对于其他调度源，此函数返回的值是不确定的。</td>
</tr>
<tr>
<td align="left"><code>dispatch_source_get_data</code></td>
<td align="left">此函数返回与事件关联的所有未决数据。对于从文件读取数据的描述符调度源，此函数返回可读取的字节数。对于将数据写入文件的描述符分派源，如果有可用的写入空间，则此函数返回正整数。对于监视文件系统活动的描述符分发源，此函数返回一个常量，指示发生的事件的类型。有关常量的列表，请参见<code>dispatch_source_vnode_flags_t</code>枚举类型。对于流程调度源，此函数返回一个常量，指示发生的事件的类型。有关常量的列表，请参见<code>dispatch_source_proc_flags_t</code>枚举类型。对于 Mach 端口调度源，此函数返回一个常量，指示发生的事件的类型。有关常量的列表，请参见<code>dispatch_source_machport_flags_t</code>枚举类型。对于自定义调度源，此函数返回从现有数据创建的新数据值以及传递给该<code>dispatch_source_merge_data</code>函数的新数据。</td>
</tr>
<tr>
<td align="left"><code>dispatch_source_get_mask</code></td>
<td align="left">此函数返回用于创建调度源的事件标志。对于流程调度源，此函数返回调度源接收的事件的掩码。有关常量的列表，请参见<code>dispatch_source_proc_flags_t</code>枚举类型。对于具有发送权限的 Mach 端口调度源，此函数返回所需事件的掩码。有关常量的列表，请参见<code>dispatch_source_mach_send_flags_t</code>枚举类型。对于自定义 OR 调度源，此函数返回用于合并数据值的掩码。</td>
</tr>
</tbody></table>
<p>有关如何为特定类型的调度源编写和安装事件处理程序的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW22" target="_blank" rel="noopener">示例</a>，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW22" target="_blank" rel="noopener">调度源示例</a>。</p>
<h6 id="安装取消处理程序"><a href="#安装取消处理程序" class="headerlink" title="安装取消处理程序"></a>安装取消处理程序</h6><p>取消处理程序用于在发布源之前对其进行清理。对于大多数类型的调度源，取消处理程序是可选的，并且仅当您有一些与调度源相关联的自定义行为也需要更新时才需要取消处理程序。但是，对于使用描述符或 Mach 端口的调度源，必须提供取消处理程序以关闭描述符或释放 Mach 端口。否则，由于代码或系统其他部分无意识地重用了那些结构，可能导致代码中的细微错误。</p>
<p>您可以随时安装取消处理程序，但通常在创建调度源时会这样做。您可以使用<code>dispatch_source_set_cancel_handler</code>或<code>dispatch_source_set_cancel_handler_f</code>函数来安装取消处理程序，具体取决于您是要在实现中使用块对象还是函数。以下示例显示了一个简单的取消处理程序，该处理程序关闭了为调度源打开的描述符。该<code>fd</code>变量是包含描述符的捕获变量。</p>
<table>
<thead>
<tr>
<th><code>dispatch_source_set_cancel_handler（mySource，^ {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>关闭（FD）; //关闭先前打开的文件描述符。</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
</tbody></table>
<p>要查看使用取消处理程序的调度源的完整代码示例，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW6" target="_blank" rel="noopener">从描述符读取数据</a>。</p>
<h6 id="更改目标队列"><a href="#更改目标队列" class="headerlink" title="更改目标队列"></a>更改目标队列</h6><p>尽管在创建调度源时指定了要在其上运行事件和取消处理程序的队列，但是您可以随时使用该<code>dispatch_set_target_queue</code>函数来更改该队列。您可以这样做来更改处理分发源事件的优先级。</p>
<p>更改调度源的队列是异步操作，调度源会尽最大努力尽快进行更改。如果事件处理程序已经在队列中并等待处理，它将在前一个队列上执行。但是，大约在您进行更改时到达的其他事件可以在任一队列中处理。</p>
<h6 id="将自定义数据与调度源关联"><a href="#将自定义数据与调度源关联" class="headerlink" title="将自定义数据与调度源关联"></a>将自定义数据与调度源关联</h6><p>与 Grand Central Dispatch 中的许多其他数据类型一样，您可以使用该<code>dispatch_set_context</code>功能将自定义数据与调度源相关联。您可以使用上下文指针存储事件处理程序处理事件所需的任何数据。如果你存储在上下文指针任何自定义数据，您还应该安装的取消处理程序（如中所述<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW14" target="_blank" rel="noopener">安装取消处理程序</a>来释放数据时，不再需要派遣源）。</p>
<p>如果使用 blocks 实现事件处理程序，则还可以捕获局部变量并在基于块的代码中使用它们。尽管这可以减轻将数据存储在调度源的上下文指针中的需要，但您应始终谨慎使用此功能。因为调度源可能在您的应用程序中存在很长一段时间，所以在捕获包含指针的变量时应格外小心。如果可以随时释放指针所指向的数据，则应该复制数据或保留数据以防止发生这种情况。无论哪种情况，您都需要提供一个取消处理程序，以便以后释放数据。</p>
<h6 id="调度源的内存管理"><a href="#调度源的内存管理" class="headerlink" title="调度源的内存管理"></a>调度源的内存管理</h6><p>与其他调度对象一样，调度源也是引用计数的数据类型。调度源的初始引用计数为 1，可以使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数保留和释放该调度源。当队列的引用计数达到零时，系统将自动取消分配调度源数据结构。</p>
<p>由于使用了它们的方式，可以在调度源本身内部或外部管理调度源的所有权。有了外部所有权，另一个对象或代码段就拥有了调度源的所有权，并负责在不再需要时释放它。对于内部所有权，调度源拥有自己，并负责在适当的时间释放自己。尽管外部所有权很常见，但是在要创建自主调度源并让其管理代码的某些行为而无需任何进一步交互的情况下，可以使用内部所有权。例如，如果调度源被设计为响应单个全局事件，则可以让它处理该事件然后立即退出。</p>
<h4 id="调度源示例"><a href="#调度源示例" class="headerlink" title="调度源示例"></a>调度源示例</h4><p>以下各节说明如何创建和配置一些更常用的调度源。有关配置特定类型的调度源的更多信息，请参见<em>Grand Central Dispatch（GCD）参考</em>。</p>
<h6 id="创建一个计时器"><a href="#创建一个计时器" class="headerlink" title="创建一个计时器"></a>创建一个计时器</h6><p>计时器分派源按规则的基于时间的间隔生成事件。您可以使用计时器来启动需要定期执行的特定任务。例如，游戏和其他图形密集型应用程序可能使用计时器来启动屏幕或动画更新。您还可以设置计时器并使用产生的事件来检查频繁更新的服务器上的新信息。</p>
<p>所有计时器分派源都是间隔计时器，也就是说，一旦创建，它们就会以您指定的间隔传递常规事件。创建计时器分派源时，必须指定的值之一是回旋值，以使系统对计时器事件的期望精度有所了解。Leeway 的价值使系统在管理电源和唤醒内核方面具有一定的灵活性。例如，系统可以使用余量值来提前或延迟点火时间，并使它与其他系统事件更好地保持一致。因此，您应尽可能为自己的计时器指定一个回程值。</p>
<p><strong>注意：</strong> 即使您指定的回程值为 0，也永远不要期望计时器在您要求的确切纳秒时触发。该系统会尽力满足您的需求，但不能保证准确的点火时间。</p>
<p>当计算机进入睡眠状态时，所有计时器分派源都将被挂起。当计算机唤醒时，这些计时器分派源也会自动唤醒。根据计时器的配置，这种性质的暂停可能会影响计时器的下一次触发时间。如果使用<code>dispatch_time</code>函数或<code>DISPATCH_TIME_NOW</code>常量设置计时器分派源，则计时器分派源将使用默认系统时钟来确定何时触发。但是，计算机睡眠时默认时钟不会提前。相比之下，当您使用<code>dispatch_walltime</code>功能，计时器分派源将其触发时间跟踪到挂钟时间。后一个选项通常适用于触发间隔相对较大的计时器，因为它可以防止事件时间之间的漂移过大。</p>
<p>清单 4-1 展示了一个计时器的示例，该计时器每 30 秒触发一次，回旋值为 1 秒。因为计时器间隔相对较大，所以使用该<code>dispatch_walltime</code>函数创建了调度源。计时器的第一次触发立即发生，随后的事件每 30 秒到达一次。该<code>MyPeriodicTask</code>和<code>MyStoreTimer</code>符号代表的自定义功能，你会写实施定时行为，并存储在应用程序中的数据结构的定时器地方。</p>
<p><strong>清单 4-1</strong> 创建计时器分派源</p>
<table>
<thead>
<tr>
<th><code>dispatch_source_t CreateDispatchTimer（uint64_t时间间隔，</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>uint64_t leeway，</code></td>
</tr>
<tr>
<td><code>dispatch_queue_t队列，</code></td>
</tr>
<tr>
<td><code>dispatch_block_t块）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>dispatch_source_t计时器= dispatch_source_create（DISPATCH_SOURCE_TYPE_TIMER，</code></td>
</tr>
<tr>
<td><code>0，0，队列）；</code></td>
</tr>
<tr>
<td><code>如果（定时器）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_timer（timer，dispatch_walltime（NULL，0），interval，leeway）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（timer，block）;</code></td>
</tr>
<tr>
<td><code>dispatch_resume（timer）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>返回计时器；</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>无效的MyCreateTimer（）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>dispatch_source_t aTimer = CreateDispatchTimer（30ull * NSEC_PER_SEC，</code></td>
</tr>
<tr>
<td><code>1ull * NSEC_PER_SEC，</code></td>
</tr>
<tr>
<td><code>dispatch_get_main_queue（），</code></td>
</tr>
<tr>
<td><code>^ {MyPeriodicTask（）; }）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将其存储在以后的地方。</code></td>
</tr>
<tr>
<td><code>如果（aTimer）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>MyStoreTimer（aTimer）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
</tbody></table>
<p>尽管创建计时器分派源是接收基于时间的事件的主要方法，但是还有其他可用选项。如果要在指定的时间间隔后执行一次块，可以使用<code>dispatch_after</code>或<code>dispatch_after_f</code>函数。该函数的行为与该<code>dispatch_async</code>函数非常相似，不同之处在于，它允许您指定将块提交到队列的时间值。可以根据需要将时间值指定为相对或绝对时间值。</p>
<h6 id="从描述符读取数据"><a href="#从描述符读取数据" class="headerlink" title="从描述符读取数据"></a>从描述符读取数据</h6><p>要从文件或套接字读取数据，必须打开文件或套接字并创建类型的调度源<code>DISPATCH_SOURCE_TYPE_READ</code>。您指定的事件处理程序应该能够读取和处理文件描述符的内容。对于文件，这相当于读取文件数据（或该数据的子集）并为您的应用程序创建适当的数据结构。对于网络套接字，这涉及处理新接收到的网络数据。</p>
<p>每当读取数据时，都应始终将描述符配置为使用非阻塞操作。尽管您可以使用该<code>dispatch_source_get_data</code>函数查看可读取的数据量，但该函数返回的数字可能会在调用时间和实际读取数据的时间之间发生变化。如果基础文件被截断或发生网络错误，则从阻止当前线程的描述符读取将使事件处理程序停滞在执行中，并阻止调度队列调度其他任务。对于串行队列，这可能会死锁您的队列，甚至对于并发队列，这也会减少可以启动的新任务的数量。</p>
<p>清单 4-2 显示了一个示例，该示例将调度源配置为从文件读取数据。在此示例中，事件处理程序将指定文件的全部内容读取到缓冲区中，并调用自定义函数（您将在自己的代码中定义）以处理数据。（此函数的调用者将在读取操作完成后使用返回的分派源将其取消。）为确保在没有要读取的数据时分派队列不会不必要地阻塞，此示例使用此<code>fcntl</code>函数来配置文件描述符以执行非阻塞操作。安装在调度源上的取消处理程序可确保在读取数据后关闭文件描述符。</p>
<p><strong>清单 4-2</strong> 从文件读取数据</p>
<table>
<thead>
<tr>
<th><code>dispatch_source_t ProcessContentsOfFile（const char *文件名）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>//准备要读取的文件。</code></td>
</tr>
<tr>
<td><code>int fd = open（文件名，O_RDONLY）;</code></td>
</tr>
<tr>
<td><code>如果（fd == -1）</code></td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td><code>fcntl（fd，F_SETFL，O_NONBLOCK）; //避免阻塞读取操作</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_t readSource = dispatch_source_create（DISPATCH_SOURCE_TYPE_READ，</code></td>
</tr>
<tr>
<td><code>fd，0，队列）;</code></td>
</tr>
<tr>
<td><code>如果（！readSource）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>关闭（FD）;</code></td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//安装事件处理程序</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（readSource，^ {</code></td>
</tr>
<tr>
<td><code>估计的size_t = dispatch_source_get_data（readSource）+ 1;</code></td>
</tr>
<tr>
<td><code>//将数据读入文本缓冲区。</code></td>
</tr>
<tr>
<td><code>char *缓冲区=（char *）malloc（估计）;</code></td>
</tr>
<tr>
<td><code>如果（缓冲区）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>ssize_t actual = read（fd，buffer，（estimated））;</code></td>
</tr>
<tr>
<td><code>布尔值完成= MyProcessFileData（缓冲区，实际）; //处理数据。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//完成后释放缓冲区。</code></td>
</tr>
<tr>
<td><code>免费（缓冲区）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//如果没有更多数据，请取消源。</code></td>
</tr>
<tr>
<td><code>如果（完成）</code></td>
</tr>
<tr>
<td><code>dispatch_source_cancel（readSource）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//安装取消处理程序</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_cancel_handler（readSource，^ {close（fd）;}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//开始读取文件。</code></td>
</tr>
<tr>
<td><code>dispatch_resume（readSource）;</code></td>
</tr>
<tr>
<td><code>返回readSource;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>在前面的示例中，自定义<code>MyProcessFileData</code>函数确定何时已读取足够的文件数据以及可以取消调度源。默认情况下，配置为从描述符读取的调度源在仍有数据需要读取的情况下重复调度其事件处理程序。如果套接字连接关闭或到达文件末尾，则调度源将自动停止调度事件处理程序。如果您知道自己不需要调度源，则可以直接取消它。</p>
<h6 id="将数据写入描述符"><a href="#将数据写入描述符" class="headerlink" title="将数据写入描述符"></a>将数据写入描述符</h6><p>将数据写入文件或套接字的过程与读取数据的过程非常相似。配置用于写操作的描述符后，您将创建类型的调度源<code>DISPATCH_SOURCE_TYPE_WRITE</code>。创建该调度源后，系统将调用事件处理程序，使其有机会开始将数据写入文件或套接字。完成数据写入后，请使用该<code>dispatch_source_cancel</code>功能取消调度源。</p>
<p>每当写入数据时，都应始终将文件描述符配置为使用非阻塞操作。尽管可以使用该<code>dispatch_source_get_data</code>函数查看有多少空间可用于写入，但是该函数返回的值仅是建议性的，并且可能在调用时间和实际写入数据的时间之间发生变化。如果发生错误，将数据写入阻塞文件描述符可能会使事件处理程序停滞在执行中，并阻止调度队列调度其他任务。对于串行队列，这可能会死锁您的队列，甚至对于并发队列，这也会减少可以启动的新任务的数量。</p>
<p>清单 4-3 显示了使用调度源将数据写入文件的基本方法。创建新文件后，此函数将结果文件描述符传递到其事件处理程序。该<code>MyGetData</code>函数提供了放入文件中的数据，您可以将其替换为生成文件数据所需的任何代码。将数据写入文件后，事件处理程序将取消调度源，以防止再次调用该调度源。然后，调度源的所有者将负责释放它。</p>
<p><strong>清单 4-3</strong> 将数据写入文件</p>
<table>
<thead>
<tr>
<th><code>dispatch_source_t WriteDataToFile（const char *文件名）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td>`int fd = open（filename，O_WRONLY</td>
</tr>
<tr>
<td>`（S_IRUSR</td>
</tr>
<tr>
<td><code>如果（fd == -1）</code></td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td><code>fcntl（fd，F_SETFL）; //在写入期间阻塞。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_t writeSource = dispatch_source_create（DISPATCH_SOURCE_TYPE_WRITE，</code></td>
</tr>
<tr>
<td><code>fd，0，队列）;</code></td>
</tr>
<tr>
<td><code>如果（！writeSource）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>关闭（FD）;</code></td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（writeSource，^ {</code></td>
</tr>
<tr>
<td><code>size_t bufferSize = MyGetDataSize（）;</code></td>
</tr>
<tr>
<td><code>void * buffer = malloc（bufferSize）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>size_t实际= MyGetData（缓冲区，bufferSize）;</code></td>
</tr>
<tr>
<td><code>写（fd，缓冲区，实际）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>免费（缓冲区）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//完成后取消并释放调度源。</code></td>
</tr>
<tr>
<td><code>dispatch_source_cancel（writeSource）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_source_set_cancel_handler（writeSource，^ {close（fd）;}）;</code></td>
</tr>
<tr>
<td><code>dispatch_resume（writeSource）;</code></td>
</tr>
<tr>
<td><code>返回（writeSource）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<h6 id="监视文件系统对象"><a href="#监视文件系统对象" class="headerlink" title="监视文件系统对象"></a>监视文件系统对象</h6><p>如果要监视文件系统对象的更改，则可以设置类型的调度源<code>DISPATCH_SOURCE_TYPE_VNODE</code>。当文件被删除，写入或重命名时，可以使用这种类型的调度源来接收通知。当文件的特定类型的元信息（例如文件的大小和链接数）发生变化时，您还可以使用它来发出警报。</p>
<p><strong>注意：</strong> 当源本身正在处理事件时，您为调度源指定的文件描述符必须保持打开状态。</p>
<p>清单 4-4 显示了一个示例，该示例监视文件的名称更改并在文件更改时执行一些自定义行为。（您将提供实际的行为来代替<code>MyUpdateFileName</code>示例中所调用的函数。）由于已为调度源专门打开了描述符，所以调度源包括一个取消处理程序，用于关闭描述符。因为该示例创建的文件描述符与基础文件系统对象相关联，所以可以使用此相同的调度源来检测任意数量的文件名更改。</p>
<p><strong>清单 4-4</strong> 监视文件名更改</p>
<table>
<thead>
<tr>
<th><code>dispatch_source_t MonitorNameChangesToFile（const char *文件名）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>int fd = open（文件名，O_EVTONLY）;</code></td>
</tr>
<tr>
<td><code>如果（fd == -1）</code></td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_t source = dispatch_source_create（DISPATCH_SOURCE_TYPE_VNODE，</code></td>
</tr>
<tr>
<td><code>fd，DISPATCH_VNODE_RENAME，队列）；</code></td>
</tr>
<tr>
<td><code>如果（来源）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>//复制文件名以供以后使用。</code></td>
</tr>
<tr>
<td><code>int length = strlen（文件名）;</code></td>
</tr>
<tr>
<td><code>char * newString =（char *）malloc（长度+1）;</code></td>
</tr>
<tr>
<td><code>newString = strcpy（newString，文件名）;</code></td>
</tr>
<tr>
<td><code>dispatch_set_context（source，newString）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//安装事件处理程序以处理名称更改</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（source，^ {</code></td>
</tr>
<tr>
<td><code>const char * oldFilename =（char *）dispatch_get_context（源）;</code></td>
</tr>
<tr>
<td><code>MyUpdateFileName（oldFilename，fd）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//安装取消处理程序以释放描述符</code></td>
</tr>
<tr>
<td><code>//和存储的字符串。</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_cancel_handler（来源，^ {</code></td>
</tr>
<tr>
<td><code>char * fileStr =（char *）dispatch_get_context（源）;</code></td>
</tr>
<tr>
<td><code>free（fileStr）;</code></td>
</tr>
<tr>
<td><code>关闭（FD）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//开始处理事件。</code></td>
</tr>
<tr>
<td><code>dispatch_resume（源）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>其他</code></td>
</tr>
<tr>
<td><code>关闭（FD）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>返回源</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<h6 id="监控信号"><a href="#监控信号" class="headerlink" title="监控信号"></a>监控信号</h6><p>UNIX 信号允许从其域外部操纵应用程序。应用程序可以接收许多不同类型的信号，范围从不可恢复的错误（例如非法指令）到有关重要信息的通知（例如子进程退出时）。传统上，应用程序使用该<code>sigaction</code>功能来安装信号处理程序功能，该功能在信号到达后立即进行同步处理。如果您只想收到信号到达的通知，而实际上却不想处理该信号，则可以使用信号分配源来异步处理信号。</p>
<p>信号分发源不能替代您使用该<code>sigaction</code>功能安装的同步信号处理程序。同步信号处理程序实际上可以捕获信号并防止其终止您的应用程序。信号分发源允许您仅监视信号的到达。此外，您不能使用信号分发源来检索所有类型的信号。特别是，你不能用它们来监控<code>SIGILL</code>，<code>SIGBUS</code>以及<code>SIGSEGV</code>信号。</p>
<p>因为信号调度源在调度队列上异步执行，所以它们不受与同步信号处理程序相同的限制。例如，您可以从信号分配源的事件处理程序调用的函数没有任何限制。这种灵活性的折衷是，在信号到达的时间与调度源的事件处理程序被调用之间的延迟可能会有所增加。</p>
<p>清单 4-5 显示了如何配置信号分发源来处理<code>SIGHUP</code>信号。调度源的事件处理程序调用该<code>MyProcessSIGHUP</code>函数，您可以在应用程序中将其替换为用于处理信号的代码。</p>
<p><strong>清单 4-5</strong> 安装一个监视信号的块</p>
<table>
<thead>
<tr>
<th><code>无效InstallSignalHandler（）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>//确保信号不会终止应用程序。</code></td>
</tr>
<tr>
<td><code>信号（SIGHUP，SIG_IGN）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_t source = dispatch_source_create（DISPATCH_SOURCE_TYPE_SIGNAL，SIGHUP，0，队列）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（来源）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（source，^ {</code></td>
</tr>
<tr>
<td><code>MyProcessSIGHUP（）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//开始处理信号</code></td>
</tr>
<tr>
<td><code>dispatch_resume（源）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>如果您正在为自定义框架开发代码，则使用信号分发源的优点是您的代码可以独立于与其链接的任何应用程序监视信号。信号调度源不会干扰应用程序可能已安装的其他调度源或任何同步信号处理程序。</p>
<p>有关实现同步信号处理程序的更多信息，以及信号名称的列表，请参见<code>signal</code>手册页。</p>
<h6 id="监控过程"><a href="#监控过程" class="headerlink" title="监控过程"></a>监控过程</h6><p>流程调度源使您可以监视特定流程的行为并做出适当响应。父进程可能使用这种类型的调度源来监视它创建的任何子进程。例如，父进程可以使用它来监视子进程的死亡。同样，子进程可以使用它来监视其父进程并在父进程退出时退出。</p>
<p>清单 4-6 显示了安装调度源以监视父进程终止的步骤。当父进程死亡时，调度源将设置一些内部状态信息，以使子进程知道应该退出。（您自己的应用程序将需要实现<code>MySetAppExitFlag</code>为终止设置适当标志的功能。）由于调度源是自动运行的，因此拥有自己的资源，因此它在预期程序关闭时也会取消并释放自身。</p>
<p><strong>清单 4-6</strong> 监视父进程的死亡</p>
<table>
<thead>
<tr>
<th><code>void MonitorParentProcess（）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>pid_t parentPID = getppid（）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_t source = dispatch_source_create（DISPATCH_SOURCE_TYPE_PROC，</code></td>
</tr>
<tr>
<td><code>parentPID，DISPATCH_PROC_EXIT，队列）；</code></td>
</tr>
<tr>
<td><code>如果（来源）</code></td>
</tr>
<tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>dispatch_source_set_event_handler（source，^ {</code></td>
</tr>
<tr>
<td><code>MySetAppExitFlag（）;</code></td>
</tr>
<tr>
<td><code>dispatch_source_cancel（source）;</code></td>
</tr>
<tr>
<td><code>dispatch_release（源代码）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td><code>dispatch_resume（源）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<h4 id="取消派遣源"><a href="#取消派遣源" class="headerlink" title="取消派遣源"></a>取消派遣源</h4><p>调度源将保持活动状态，直到您使用该<code>dispatch_source_cancel</code>功能明确取消它们为止。取消调度源将停止新事件的传递，并且无法撤消。因此，通常您取消调度源，然后立即释放它，如下所示：</p>
<table>
<thead>
<tr>
<th><code>void RemoveDispatchSource（dispatch_source_t mySource）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>{</code></td>
</tr>
<tr>
<td><code>dispatch_source_cancel（mySource）;</code></td>
</tr>
<tr>
<td><code>dispatch_release（mySource）;</code></td>
</tr>
<tr>
<td><code>}</code></td>
</tr>
</tbody></table>
<p>取消调度源是异步操作。尽管在调用<code>dispatch_source_cancel</code>函数后没有任何新事件被处理，但是调度源已经处理的事件将继续被处理。完成任何最终事件的处理后，如果存在一个派发源，则派发源执行其取消处理程序。</p>
<p>取消处理程序是您释放内存或清理代表调度源获取的任何资源的机会。如果您的调度源使用描述符或马赫端口，则必须提供取消处理程序以关闭描述符或在发生取消时销毁端口。其他类型的调度源不需要取消处理程序，但是如果将任何内存或数据与调度源关联，您仍应提供取消处理程序。例如，如果将数据存储在调度源的上下文指针中，则应提供一个。有关取消处理程序的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW14" target="_blank" rel="noopener">安装取消处理程序</a>。</p>
<h4 id="挂起和恢复派遣源"><a href="#挂起和恢复派遣源" class="headerlink" title="挂起和恢复派遣源"></a>挂起和恢复派遣源</h4><p>您可以使用<code>dispatch_suspend</code>和<code>dispatch_resume</code>方法临时暂停和恢复分发源事件的传递。这些方法增加和减少调度对象的挂起计数。因此，在恢复事件传递之前，您必须在<code>dispatch_suspend</code>与每个呼叫之间找到一个与之匹配的呼叫<code>dispatch_resume</code>。</p>
<p>当您挂起调度源时，该调度源被挂起时发生的任何事件都将被累积，直到恢复队列为止。当队列恢复时，而不是传递所有事件，而是在传递之前将事件合并为单个事件。例如，如果您正在监视文件中的名称更改，则传递的事件将仅包括姓氏更改。以这种方式合并事件可以防止它们在队列中建立，并在工作恢复时使您的应用程序不堪重负。</p>
<h2 id="远离线程-1"><a href="#远离线程-1" class="headerlink" title="远离线程"></a>远离线程</h2><p>有多种方法可以使现有的线程代码适应使用 Grand Central Dispatch 和操作对象的优势。尽管并非在所有情况下都可能远离线程，但是在您进行切换的地方，性能（以及代码的简单性）可以显着提高。特别是，使用调度队列和操作队列而不是线程具有多个优点：</p>
<ul>
<li>它减少了您的应用程序为将线程堆栈存储在应用程序的内存空间中而付出的内存损失。</li>
<li>它消除了创建和配置线程所需的代码。</li>
<li>它消除了管理和调度线程上的工作所需的代码。</li>
<li>它简化了您必须编写的代码。</li>
</ul>
<p>本章提供有关如何替换现有的基于线程的代码以及如何使用分派队列和操作队列来实现相同类型行为的提示和准则。</p>
<h4 id="用调度队列替换线程"><a href="#用调度队列替换线程" class="headerlink" title="用调度队列替换线程"></a>用调度队列替换线程</h4><p>要了解如何用调度队列替换线程，请首先考虑您今天在应用程序中使用线程的一些方式：</p>
<ul>
<li><strong>单任务线程</strong>。创建一个线程来执行一个任务，并在任务完成后释放线程。</li>
<li><strong>工作者线程</strong>。创建一个或多个工作线程，并为每个线程记住特定的任务。定期将任务分配给每个线程。</li>
<li><strong>线程池</strong>。创建一个通用线程池，并为每个线程建立运行循环。当您有任务要执行时，请从池中获取一个线程，然后将任务分派给该线程。如果没有可用线程，则将任务排队并等待线程可用。</li>
</ul>
<p>尽管这些技术看似截然不同，但它们实际上只是相同原理的变体。在每种情况下，都使用线程来运行应用程序必须执行的某些任务。它们之间的唯一区别是用于管理线程和任务排队的代码。使用调度队列和操作队列，您可以消除所有线程和线程通信代码，而只专注于要执行的任务。</p>
<p>如果您正在使用上述线程模型之一，则应该已经对应用程序执行的任务类型有一个很好的了解。与其将任务提交给您的自定义线程之一，不如将该任务封装在一个操作对象或一个块对象中，然后将其分派到适当的队列中。对于不是特别有争议的任务（即不带锁的任务），您应该能够进行以下直接替换：</p>
<ul>
<li>对于单个任务线程，将任务封装在块或操作对象中，然后将其提交到并发队列。</li>
<li>对于辅助线程，您需要确定是使用串行队列还是并发队列。如果使用工作线程来同步特定任务集的执行，请使用串行队列。如果确实使用工作线程执行没有相互依赖性的任意任务，请使用并发队列。</li>
<li>对于线程池，将您的任务封装在一个块或操作对象中，然后将它们分派到并发队列中以执行。</li>
</ul>
<p>当然，像这样的简单替换不一定在所有情况下都有效。如果您正在执行的任务争用共享资源，则理想的解决方案是尝试首先删除或最小化该争用。如果有一些方法可以重构或重新构造代码以消除对共享资源的相互依赖，那当然是可取的。但是，如果这样做是不可能的或效率可能较低，则仍然可以利用队列的方法。队列的一大优点是它们提供了一种更可预测的方式来执行代码。这种可预测性意味着，仍有许多方法可以在不使用锁或其他重量级同步机制的情况下同步代码的执行。除了使用锁，您还可以使用队列来执行许多相同的任务：</p>
<ul>
<li>如果您有必须按特定顺序执行的任务，请将其提交到串行调度队列。如果您更喜欢使用操作队列，请使用操作对象依赖性来确保这些对象以特定顺序执行。</li>
<li>如果当前正在使用锁来保护共享资源，请创建一个串行队列以执行任何修改该资源的任务。然后，串行队列将您现有的锁替换为同步机制。有关摆脱锁的更多信息技术，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW3" target="_blank" rel="noopener">消除基于锁的代码</a>。</li>
<li>如果使用线程连接等待后台任务完成，请考虑改用调度组。您还可以使用 <code>NSBlockOperation</code>对象或操作对象依赖项来实现类似的组完成行为。有关如何跟踪执行任务组的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW6" target="_blank" rel="noopener">替换线程联接</a>。</li>
<li>如果您使用生产者－消费者算法来管理有限的资源池，请考虑将您的实现<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW7" target="_blank" rel="noopener">更改为“更改生产者－消费者实现”中显示的方法</a>。</li>
<li>如果您正在使用线程从描述符读取和写入，或监视文件操作，请按照<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">Dispatch Sources 中的</a>说明使用<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">调度源</a>。</li>
</ul>
<p>重要的是要记住，队列不是替换线程的灵丹妙药。队列提供的异步编程模型适合于延迟不成问题的情况。即使队列提供了配置队列中任务执行优先级的方法，但是较高的执行优先级也不能保证在特定时间执行任务。因此，在需要最小延迟的情况下，例如在音频和视频播放中，线程仍然是更合适的选择。</p>
<h4 id="消除基于锁的代码"><a href="#消除基于锁的代码" class="headerlink" title="消除基于锁的代码"></a>消除基于锁的代码</h4><p>对于线程代码，锁是同步对线程之间共享的资源的访问的传统方法之一。但是，使用锁是有代价的。即使在无争议的情况下，始终会因锁定而导致性能下降。并且在有争议的情况下，在等待释放锁的同时，一个或多个线程有可能在不确定的时间内阻塞。</p>
<p>用队列替换基于锁的代码可以消除许多与锁相关的惩罚，还可以简化剩余的代码。您可以使用创建队列来序列化访问该资源的任务，而不必使用锁来保护共享资源。队列不会施加与锁相同的惩罚。例如，排队任务不需要陷入内核即可获取互斥量。</p>
<p>在对任务进行排队时，您必须做出的主要决定是同步还是异步进行。异步提交任务可以使当前线程在执行任务时继续运行。同步提交任务会阻塞当前线程，直到任务完成。这两个选项都有适当的用途，尽管在可能的情况下异步提交任务无疑是有利的。</p>
<p>以下各节说明如何用等效的基于队列的代码替换现有的基于锁的代码。</p>
<h6 id="实现异步锁"><a href="#实现异步锁" class="headerlink" title="实现异步锁"></a>实现异步锁</h6><p>异步锁定是一种保护共享资源而又不会阻止任何修改该资源的代码的方法。当需要修改数据结构时，您可能会使用异步锁，这是代码正在执行的其他一些工作的副作用。使用传统线程，通常实现此代码的方式是对共享资源进行锁定，进行必要的更改，释放该锁定，然后继续执行任务的主要部分。但是，使用调度队列，调用代码可以异步进行修改，而无需等待这些更改完成。</p>
<p>清单 5-1 显示了一个异步锁实现的示例。在此示例中，受保护的资源定义了自己的串行调度队列。调用代码向该队列提交一个块对象，该对象包含需要对资源进行的修改。由于队列本身是串行执行块的，因此可以确保对资源的更改按照接收到的顺序进行。但是，由于任务是异步执行的，因此调用线程不会阻塞。</p>
<p><strong>清单 5-1</strong> 异步修改受保护的资源</p>
<table>
<thead>
<tr>
<th><code>dispatch_async（obj-&gt; serial_queue，^ {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>//关键部分</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
</tbody></table>
<h6 id="同步执行关键部分"><a href="#同步执行关键部分" class="headerlink" title="同步执行关键部分"></a>同步执行关键部分</h6><p>如果在给定任务完成之前当前代码无法继续，则可以使用<code>dispatch_sync</code>函数同步提交任务。此函数将任务添加到调度队列，然后阻塞当前线程，直到任务完成执行。分派队列本身可以是串行或并发队列，具体取决于您的需求。由于此函数会阻止当前线程，因此，仅应在必要时使用它。清单 5-2 显示了使用来包装代码的关键部分的技术<code>dispatch_sync</code>。</p>
<p><strong>清单 5-2</strong> 同步运行关键部分</p>
<table>
<thead>
<tr>
<th><code>dispatch_sync（my_queue，^ {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>//关键部分</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
</tbody></table>
<p>如果您已经在使用串行队列来保护共享资源，则与异步分发相比，同步分派到该队列不会更多地保护共享资源。同步分派的唯一原因是防止当前代码在关键部分结束之前继续执行。例如，如果您想从共享资源中获取一些价值并立即使用它，则需要同步调度。如果当前代码不需要等待关键部分完成，或者可以简单地将其他后续任务提交到同一串行队列，则通常首选异步提交。</p>
<h4 id="改进循环代码"><a href="#改进循环代码" class="headerlink" title="改进循环代码"></a>改进循环代码</h4><p>如果您的代码具有循环，并且每次循环执行的工作都与其他迭代中完成的工作无关，则可以考虑使用<code>dispatch_apply</code>or <code>dispatch_apply_f</code>函数重新实现该循环代码。这些函数将循环的每次迭代分别提交给调度队列进行处理。与并发队列一起使用时，此功能使您可以同时执行循环的多次迭代。</p>
<p>该<code>dispatch_apply</code>和<code>dispatch_apply_f</code>功能是阻止执行的当前线程，直到所有的循环迭代是完全同步的函数调用。当提交到并发队列时，不能保证循环迭代的执行顺序。运行每次迭代的线程可能会阻塞并导致给定的迭代在其周围的其他线程之前或之后完成。因此，用于每次循环迭代的块对象或函数必须是可重入的。</p>
<p>清单 5-3 显示了如何<code>for</code>用基于派遣的等效项替换循环。您传递给的块或函数<code>dispatch_apply</code>或<code>dispatch_apply_f</code>必须采用指示当前循环迭代的整数值。在此示例中，代码仅将当前循环号打印到控制台。</p>
<p><strong>清单 5-3</strong><code>for</code>不跨步地 替换循环</p>
<table>
<thead>
<tr>
<th><code>队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>dispatch_apply（count，queue，^（size_t i）{</code></td>
</tr>
<tr>
<td><code>printf（“％u \ n”，i）;</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
</tbody></table>
<p>尽管前面的示例是一个简单的示例，但是它演示了使用分派队列替换循环的基本技术。尽管这可能是提高基于循环的代码性能的好方法，但仍必须谨慎地使用此技术。尽管分派队列的开销非常低，但是在线程上安排每次循环迭代仍然有成本。因此，您应该确保您的循环代码能够完成足够的工作以保证成本。您到底需要做多少工作，这是您必须使用性能工具来衡量的。</p>
<p>一种增加每次循环迭代中的工作量的简单方法是使用跨步。跨步时，您可以重写块代码以执行原始循环的多次迭代。然后，您可以<code>dispatch_apply</code>按比例减少为函数指定的计数值。清单 5-4 显示了如何实现<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW5" target="_blank" rel="noopener">清单 5-3</a>所示的循环代码的跨步。在清单 5-4 中，该块调用该<code>printf</code>语句的次数与步幅值的次数相同，在本例中为 137。（实际步幅值应根据代码所完成的工作进行配置。）当将迭代总数除以步幅值时，会剩下余数，任何余下的迭代都将内联执行。</p>
<p><strong>清单 5-4</strong> 在已调度的 for 循环中添加跨步</p>
<table>
<thead>
<tr>
<th><code>国际步幅= 137;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>dispatch_queue_t队列= dispatch_get_global_queue（DISPATCH_QUEUE_PRIORITY_DEFAULT，0）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>dispatch_apply（计数/步幅，队列，^（size_t idx）{</code></td>
</tr>
<tr>
<td><code>size_t j = idx *步幅；</code></td>
</tr>
<tr>
<td><code>size_t j_stop = j +步幅；</code></td>
</tr>
<tr>
<td><code>做{</code></td>
</tr>
<tr>
<td><code>printf（“％u \ n”，（unsigned int）j ++）;</code></td>
</tr>
<tr>
<td>` }同时（j</td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>size_t i;</code></td>
</tr>
<tr>
<td><code>对于（i =计数-（计数％步幅）; i &lt;计数; i ++）</code></td>
</tr>
<tr>
<td><code>printf（“％u \ n”，（unsigned int）i）;</code></td>
</tr>
</tbody></table>
<p>使用跨步有一定的性能优势。特别是，相对于跨度，当循环迭代的原始数量较高时，跨度会带来好处。同时分派更少的块意味着比分派它们花费更多的时间来执行那些块的代码。但是，与任何性能指标一样，您可能必须使用跨步值才能找到代码的最有效值。</p>
<h4 id="替换线程连接"><a href="#替换线程连接" class="headerlink" title="替换线程连接"></a>替换线程连接</h4><p>线程连接允许您生成一个或多个线程，然后让当前线程等待，直到这些线程完成。为了实现线程连接，父级将子线程创建为<em>可连接线程</em>。如果父级在没有子线程的结果的情况下无法取得进展时，它将与子级一起加入。此过程将阻塞父线程，直到子线程完成其任务并退出为止，此时，父线程可以从子线程收集结果并继续自己的工作。如果父级需要与多个子线程联接，则一次联接一个。</p>
<p>调度组提供的语义类似于线程联接的语义，但具有一些其他优点。像线程连接一样，调度组是线程阻塞直到一个或多个子任务完成执行的一种方式。与线程连接不同，调度组同时等待其所有子任务。并且由于调度组使用调度队列执行工作，因此它们非常高效。</p>
<p>要使用调度组来执行可连接线程执行的相同工作，请执行以下操作：</p>
<ol>
<li>使用<code>dispatch_group_create</code>函数创建一个新的调度组。</li>
<li>使用<code>dispatch_group_async</code>或<code>dispatch_group_async_f</code>函数将任务添加到组中。提交给组的每个任务代表您通常在可连接线程上执行的工作。</li>
<li>当当前线程无法再进行任何转发时，请调用该<code>dispatch_group_wait</code>函数以等待该组。该功能将阻塞当前线程，直到该组中的所有任务完成执行为止。</li>
</ol>
<p>如果使用操作对象来实现任务，则还可以使用依赖项来实现线程联接。无需让父线程等待一个或多个任务完成，您可以将父代码移动到操作对象。然后，您将在父操作对象和任意数量的子操作对象之间建立依赖关系，以建立可连接线程通常执行的工作。依赖于其他操作对象会阻止父操作对象在所有操作完成之前执行。</p>
<p>有关如何使用调度组的示例，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW25" target="_blank" rel="noopener">等待队列中的任务组</a>。有关在操作对象之间设置依赖关系的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17" target="_blank" rel="noopener">配置互操作依赖关系</a>。</p>
<h4 id="更改生产者-消费者实施"><a href="#更改生产者-消费者实施" class="headerlink" title="更改生产者-消费者实施"></a>更改生产者-消费者实施</h4><p>生产者－消费者模型使您可以管理有限数量的动态产生的资源。生产者创建新资源（或工作）时，一个或多个消费者等待这些资源（或工作）准备就绪并在使用时消费它们。实现生产者－消费者模型的典型机制是条件或信号量。</p>
<p>使用条件，生产者线程通常执行以下操作：</p>
<ol>
<li>锁定与条件关联的互斥锁（使用<code>pthread_mutex_lock</code>）。</li>
<li>生产要消耗的资源或工作。</li>
<li>向条件变量发出要消耗一些东西的信号（使用<code>pthread_cond_signal</code>）</li>
<li>解锁互斥锁（使用<code>pthread_mutex_unlock</code>）。</li>
</ol>
<p>反过来，相应的使用者线程执行以下操作：</p>
<ol>
<li>锁定与条件关联的互斥锁（使用<code>pthread_mutex_lock</code>）。</li>
<li>设置<code>while</code>循环以执行以下操作：<ol>
<li>检查是否确实有工作要做。</li>
<li>如果没有工作要做（或没有可用资源），请调用<code>pthread_cond_wait</code>以阻塞当前线程，直到出现相应的信号为止。</li>
</ol>
</li>
<li>获取制作人提供的作品（或资源）。</li>
<li>解锁互斥锁（使用<code>pthread_mutex_unlock</code>）。</li>
<li>处理工作。</li>
</ol>
<p>使用调度队列，您可以将生产者和使用者实现简化为一个调用：</p>
<table>
<thead>
<tr>
<th><code>dispatch_async（queue，^ {</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>//处理工作项。</code></td>
</tr>
<tr>
<td><code>}）;</code></td>
</tr>
</tbody></table>
<p>当您的生产者有工作要做时，它要做的就是将工作添加到队列中，并让队列处理该项目。前面代码中唯一更改的部分是队列类型。如果生产者生成的任务需要按特定顺序执行，则可以使用串行队列。如果生产者生成的任务可以同时执行，则可以将它们添加到并发队列中，并让系统同时执行尽可能多的任务。</p>
<h4 id="替换信号量代码"><a href="#替换信号量代码" class="headerlink" title="替换信号量代码"></a>替换信号量代码</h4><p>如果当前正在使用信号量来限制对共享资源的访问，则应考虑使用调度信号量。传统的信号量始终要求调用内核来测试信号量。相反，调度信号量会在用户空间中快速测试信号量状态，并仅在测试失败并且需要阻塞调用线程时才捕获到内核中。这种情况导致在没有争议的情况下，调度信号量比传统信号量快得多。但是，在所有其他方面，调度信号量提供的行为与传统信号量相同。</p>
<p>有关如何使用调度信号量的示例，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24" target="_blank" rel="noopener">使用调度信号量来调节有限资源的使用</a>。</p>
<h4 id="替换运行循环代码"><a href="#替换运行循环代码" class="headerlink" title="替换运行循环代码"></a>替换运行循环代码</h4><p>如果您使用运行循环来管理在一个或多个线程上执行的工作，则可能会发现队列的实现和维护更加简单。设置自定义运行循环涉及设置基础线程和运行循环本身。运行循环代码包括设置一个或多个运行循环源以及编写回调以处理到达这些源的事件。除了完成所有工作之外，您只需创建一个串行队列并将任务分派给它即可。因此，您可以用一行代码替换所有线程和运行循环创建代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myNewRunLoop = dispatch_queue_create（“ com.apple.MyQueue”，NULL）;</span><br></pre></td></tr></table></figure>

<p>因为队列自动执行添加到队列中的所有任务，所以不需要额外的代码来管理队列。您不必创建或配置线程，也不必创建或附加任何运行循环源。此外，您只需在队列中添加任务即可执行新的工作类型。要对运行循环执行相同的操作，您将需要修改现有的运行循环源或创建一个新的源来处理新数据。</p>
<p>运行循环的一种常见配置是处理异步到达网络套接字的数据。您可以将调度源附加到所需的队列，而不是为此类型的行为配置运行循环。与传统的运行循环源相比，调度源还提供了更多的数据处理选项。除了处理计时器和网络端口事件，您还可以使用调度源来读取和写入文件，监视文件系统对象，监视进程和监视信号。您甚至可以定义自定义调度源，并从代码的其他部分异步触发它们。有关设置调度源的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">调度源</a>。</p>
<h4 id="与-POSIX-线程的兼容性"><a href="#与-POSIX-线程的兼容性" class="headerlink" title="与 POSIX 线程的兼容性"></a>与 POSIX 线程的兼容性</h4><p>因为 Grand Central Dispatch 管理着您提供的任务和运行这些任务的线程之间的关系，所以通常应该避免从任务代码中调用 POSIX 线程例程。如果确实由于某种原因需要调用它们，则应非常谨慎地调用哪些例程。本节向您说明在排队的任务中哪些例程可以安全调用，哪些例程不安全。该列表并不完整，但是应该告诉您什么是安全的，什么不是。</p>
<p>通常，您的应用程序不得删除或变异未创建的对象或数据结构。因此，使用分派队列执行的块对象不得调用以下函数：</p>
<ul>
<li><code>pthread_detach</code></li>
<li><code>pthread_cancel</code></li>
<li><code>pthread_join</code></li>
<li><code>pthread_kill</code></li>
<li><code>pthread_exit</code></li>
</ul>
<p>尽管可以在任务运行时修改线程的状态，但是必须在任务返回之前将线程返回到其原始状态。因此，只要将线程返回到其原始状态，就可以安全地调用以下函数：</p>
<ul>
<li><code>pthread_setcancelstate</code></li>
<li><code>pthread_setcanceltype</code></li>
<li><code>pthread_setschedparam</code></li>
<li><code>pthread_sigmask</code></li>
<li><code>pthread_setspecific</code></li>
</ul>
<p>用于执行给定块的基础线程可以在调用之间变化。因此，您的应用程序不应依赖以下函数，这些函数在块调用之间返回可预测的结果：</p>
<ul>
<li><code>pthread_self</code></li>
<li><code>pthread_getschedparam</code></li>
<li><code>pthread_get_stacksize_np</code></li>
<li><code>pthread_get_stackaddr_np</code></li>
<li><code>pthread_mach_thread_np</code></li>
<li><code>pthread_from_mach_thread_np</code></li>
<li><code>pthread_getspecific</code></li>
</ul>
<p><strong>重要提示：</strong> 块必须捕获并抑制其中抛出的任何语言级异常。在执行块期间发生的其他错误应类似地由该块处理或用于通知应用程序的其他部分。</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><ul>
<li>应用</li>
</ul>
<p>一种特定的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW13" target="_blank" rel="noopener">程序</a>样式，向用户显示图形界面。</p>
<ul>
<li>异步设计方法</li>
</ul>
<p>围绕可以与应用程序的主线程或其他执行线程同时运行的代码块组织应用程序的原理。异步任务由一个线程启动，但实际上在另一个线程上运行，从而利用了额外的处理器资源来更快地完成其工作。</p>
<ul>
<li>块对象</li>
</ul>
<p>一个 AC 结构，用于封装内联代码和数据，以便以后可以执行。您可以使用块来封装要执行的任务，这些任务可以内联在当前线程中，也可以使用分派队列在单独的线程中。有关更多信息，请参见*<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">块编程主题</a>*。</p>
<ul>
<li>并发操作</li>
</ul>
<p><code>start</code>在调用其方法的线程中未执行其任务的操作对象。并发操作通常会建立自己的线程或调用一个接口，该接口会建立一个单独的线程来执行工作。</p>
<ul>
<li>健康）状况</li>
</ul>
<p>用于同步对资源的访问的构造。在其他条件明确指示条件之前，不允许等待条件的线程继续进行。</p>
<ul>
<li>关键部分</li>
</ul>
<p>一次只能由一个线程执行的一部分代码。</p>
<ul>
<li>自订来源</li>
</ul>
<p>甲<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW19" target="_blank" rel="noopener">调度源</a>用于过程应用定义的事件。定制源调用定制事件处理程序以响应应用程序生成的事件。</p>
<ul>
<li>描述符</li>
</ul>
<p>用于访问文件，套接字或其他系统资源的抽象标识符。</p>
<ul>
<li>调度队列</li>
</ul>
<p>您用于执行应用程序任务的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW23" target="_blank" rel="noopener">Grand Central Dispatch（GCD）</a>结构。GCD 定义了分派队列以串行或并行执行任务。</p>
<ul>
<li>派遣源</li>
</ul>
<p>您创建的用来处理与系统相关的事件的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW23" target="_blank" rel="noopener">Grand Central Dispatch（GCD）</a>数据结构。</p>
<ul>
<li>描述符分发源</li>
</ul>
<p>一个<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW19" target="_blank" rel="noopener">调度源</a>用来处理文件相关的事件。当文件数据可用于读取或写入或响应文件系统更改时，文件描述符源将调用您的自定义事件处理程序。</p>
<ul>
<li>动态共享库</li>
</ul>
<p>二进制可执行文件，可动态加载到应用程序的进程空间中，而不是作为应用程序二进制文件的一部分静态链接。</p>
<ul>
<li>构架</li>
</ul>
<p>一种捆绑包，它将动态共享库与支持该库的资源和头文件打包在一起。有关更多信息，请参见《_<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183i" target="_blank" rel="noopener">Framework 编程指南》</a>_。</p>
<ul>
<li>全局调度队列</li>
</ul>
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW23" target="_blank" rel="noopener">Grand Central Dispatch（GCD）</a>自动为您的应用程序提供一个<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW9" target="_blank" rel="noopener">调度队列</a>。您不必自己创建全局队列，也不必保留或释放它们。而是使用系统提供的功能检索它们。</p>
<ul>
<li>大中央派遣（GCD）</li>
</ul>
<p>同时执行异步任务的技术。GCD 在 OS X v10.6 和更高版本以及 iOS 4.0 和更高版本中可用。</p>
<ul>
<li>输入源</li>
</ul>
<p>线程的异步事件的源。输入源可以基于端口，也可以手动触发，并且必须附加到线程的运行循环中。</p>
<ul>
<li>可连接线程</li>
</ul>
<p>终止后不会立即回收其资源的线程。必须先显式地分离可连接线程，否则必须由另一个线程将其连接，才能回收资源。可连接线程为与它们连接的线程提供返回值。</p>
<ul>
<li>图书馆</li>
</ul>
<p>用于监视低级系统事件的 UNIX 功能。有关更多信息，请参见 <code>kqueue</code>手册页。</p>
<ul>
<li>马赫港调度源</li>
</ul>
<p>一个<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW19" target="_blank" rel="noopener">调度源</a>用来到达一个 Mach 端口上处理事件。</p>
<ul>
<li>主线</li>
</ul>
<p>创建其拥有进程时创建的一种特殊类型的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW1" target="_blank" rel="noopener">线程</a>。当程序的主线程退出时，该过程结束。</p>
<ul>
<li>互斥体</li>
</ul>
<p>提供互斥访问共享资源的锁。互斥锁一次只能由一个线程持有。尝试获取由其他线程持有的互斥锁会使当前线程进入休眠状态，直到最终获取该锁为止。</p>
<ul>
<li>开放计算语言（OpenCL）</li>
</ul>
<p>一种基于标准的技术，用于在计算机的图形处理器上执行通用计算。有关更多信息，请参阅*<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/OpenCL_MacProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008312" target="_blank" rel="noopener">《 Mac 版 OpenCL 编程指南》</a>*。</p>
<ul>
<li>操作对象</li>
</ul>
<p><code>NSOperation</code>类的实例。操作对象将与任务关联的代码和数据包装到可执行单元中。</p>
<ul>
<li>操作队列</li>
</ul>
<p><code>NSOperationQueue</code>类的实例。操作队列管理操作对象的执行。</p>
<ul>
<li>私人调度队列</li>
</ul>
<p>一个<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW9" target="_blank" rel="noopener">调度队列</a>您创建，保存，并明确释放。</p>
<ul>
<li>处理</li>
</ul>
<p>应用程序或程序的运行时实例。进程具有自己的虚拟内存空间和系统资源（包括端口权限），与分配给其他程序的资源无关。一个进程始终至少包含一个线程（主线程），并且可以包含任意数量的附加线程。</p>
<ul>
<li>流程调度源</li>
</ul>
<p>一个<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW19" target="_blank" rel="noopener">调度源</a>用于处理进程相关的事件。流程源调用您的自定义事件处理程序，以响应对指定流程的更改。</p>
<ul>
<li>程序</li>
</ul>
<p>可以运行代码和资源以执行某些任务的组合。程序无需具有图形用户界面，尽管图形应用程序也被视为程序。</p>
<ul>
<li>可折返</li>
</ul>
<p>已经在另一个线程上运行的新线程上可以安全地启动的代码。</p>
<ul>
<li>运行循环</li>
</ul>
<p>事件处理循环，在此循环中，事件被接收并调度到适当的处理程序。</p>
<ul>
<li>运行循环模式</li>
</ul>
<p>与特定名称关联的输入源，计时器源和运行循环观察器的集合。当以特定的“模式”运行时，运行循环仅监视与该模式关联的源和观察者。</p>
<ul>
<li>运行循环对象</li>
</ul>
<p><code>NSRunLoop</code>类或<code>CFRunLoopRef</code>不透明类型的实例。这些对象提供了用于在线程中实现事件处理循环的接口。</p>
<ul>
<li>运行循环观察器</li>
</ul>
<p>运行循环执行的不同阶段中的通知的接收者。</p>
<ul>
<li>信号</li>
</ul>
<p>受保护的变量，用于限制对共享资源的访问。互斥量和条件都是信号灯的不同类型。</p>
<ul>
<li>信号</li>
</ul>
<p>一种用于从其域外部操纵进程的 UNIX 机制。系统使用信号将重要消息传递给应用程序，例如应用程序是否执行了非法指令。有关更多信息，请参见<code>signal</code>手册页。</p>
<ul>
<li>信号分配源</li>
</ul>
<p>甲<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW19" target="_blank" rel="noopener">调度源</a>用于处理 UNIX 信号。每当进程收到 UNIX 信号时，信号源就会调用您的自定义事件处理程序。</p>
<ul>
<li>任务</li>
</ul>
<p>要执行的工作量。尽管某些技术（最著名的是 Carbon Multiprocessing Services）以不同的方式使用该术语，但首选用法是作为抽象概念，指示要执行的工作量。</p>
<ul>
<li>线</li>
</ul>
<p>流程中的执行流程。每个线程都有自己的堆栈空间，但在同一进程中与其他线程共享内存。</p>
<ul>
<li>计时器调度源</li>
</ul>
<p>一个<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW19" target="_blank" rel="noopener">调度源</a>用于处理周期性事件。计时器源会定期（基于时间）调用自定义事件处理程序。</p>
<p>有关 POSIX 线程和本节中提到的功能的更多信息，请参见<code>pthread</code>手册页。</p>
<h2 id="文档修订历史"><a href="#文档修订历史" class="headerlink" title="文档修订历史"></a>文档修订历史</h2><p>下表描述了对“ <em>并发编程指南”</em>的更改。</p>
<table>
<thead>
<tr>
<th><strong>日期</strong></th>
<th><strong>笔记</strong></th>
</tr>
</thead>
<tbody><tr>
<td>2012-12-13</td>
<td>更正了调度队列的说明。</td>
</tr>
<tr>
<td>2012-07-17</td>
<td>删除了有关自动释放池在操作中的使用情况的过时信息。</td>
</tr>
<tr>
<td>2011-01-19</td>
<td>更新了用于手动执行操作的代码以正确处理取消。</td>
</tr>
<tr>
<td></td>
<td>添加了有关将 Objective-C 对象与调度队列结合使用的信息。</td>
</tr>
<tr>
<td>2010-04-13</td>
<td>更新以反映对 iOS 的支持。</td>
</tr>
<tr>
<td>2009-08-07</td>
<td>更正了非并行操作对象示例的启动方法。</td>
</tr>
<tr>
<td>2009-05-22</td>
<td>新文档描述了用于以并行方式执行多个代码路径的技术。</td>
</tr>
</tbody></table>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/donate/">Donate</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Concurrency-Programming-Guide"><span class="toc-number">1.</span> <span class="toc-text">Concurrency Programming Guide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本文件的组织"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">本文件的组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有关术语的注释"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">有关术语的注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#也可以看看"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">也可以看看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发与应用程序设计"><span class="toc-number">1.2.</span> <span class="toc-text">并发与应用程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#远离线程"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">远离线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#调度队列"><span class="toc-number">1.2.0.1.0.1.</span> <span class="toc-text">调度队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#派遣来源"><span class="toc-number">1.2.0.1.0.2.</span> <span class="toc-text">派遣来源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#操作队列"><span class="toc-number">1.2.0.1.0.3.</span> <span class="toc-text">操作队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步设计技术"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">异步设计技术</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#定义应用程序的预期行为"><span class="toc-number">1.2.0.2.0.1.</span> <span class="toc-text">定义应用程序的预期行为</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#排除可执行的工作单元"><span class="toc-number">1.2.0.2.0.2.</span> <span class="toc-text">排除可执行的工作单元</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#确定您需要的队列"><span class="toc-number">1.2.0.2.0.3.</span> <span class="toc-text">确定您需要的队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#提高效率的技巧"><span class="toc-number">1.2.0.2.0.4.</span> <span class="toc-text">提高效率的技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能影响"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">性能影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发和其他技术"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">并发和其他技术</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#OpenCL-和并发"><span class="toc-number">1.2.0.4.0.1.</span> <span class="toc-text">OpenCL 和并发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#何时使用线程"><span class="toc-number">1.2.0.4.0.2.</span> <span class="toc-text">何时使用线程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作队列-1"><span class="toc-number">1.3.</span> <span class="toc-text">操作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于操作对象"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">关于操作对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行与非并行操作"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">并行与非并行操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个-NSInvocationOperation-对象"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">创建一个 NSInvocationOperation 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建一个-NSBlockOperation-对象"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">创建一个 NSBlockOperation 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义自定义操作对象"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">定义自定义操作对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#执行主要任务"><span class="toc-number">1.3.0.5.0.1.</span> <span class="toc-text">执行主要任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#响应取消事件"><span class="toc-number">1.3.0.5.0.2.</span> <span class="toc-text">响应取消事件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#配置并发执行操作"><span class="toc-number">1.3.0.5.0.3.</span> <span class="toc-text">配置并发执行操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#保持-KVO-合规性"><span class="toc-number">1.3.0.5.0.4.</span> <span class="toc-text">保持 KVO 合规性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义操作对象的执行行为"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">自定义操作对象的执行行为</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#配置互操作依赖性"><span class="toc-number">1.3.0.6.0.1.</span> <span class="toc-text">配置互操作依赖性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更改工序的执行优先级"><span class="toc-number">1.3.0.6.0.2.</span> <span class="toc-text">更改工序的执行优先级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更改底层线程优先级"><span class="toc-number">1.3.0.6.0.3.</span> <span class="toc-text">更改底层线程优先级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#设定完成区块"><span class="toc-number">1.3.0.6.0.4.</span> <span class="toc-text">设定完成区块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实施操作对象的技巧"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">实施操作对象的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#管理操作对象中的内存"><span class="toc-number">1.3.0.7.0.1.</span> <span class="toc-text">管理操作对象中的内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#处理错误和异常"><span class="toc-number">1.3.0.7.0.2.</span> <span class="toc-text">处理错误和异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确定操作对象的适当范围"><span class="toc-number">1.3.0.8.</span> <span class="toc-text">确定操作对象的适当范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行操作"><span class="toc-number">1.3.0.9.</span> <span class="toc-text">执行操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将操作添加到操作队列"><span class="toc-number">1.3.0.9.0.1.</span> <span class="toc-text">将操作添加到操作队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#手动执行操作"><span class="toc-number">1.3.0.9.0.2.</span> <span class="toc-text">手动执行操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#取消操作"><span class="toc-number">1.3.0.9.0.3.</span> <span class="toc-text">取消操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#等待操作完成"><span class="toc-number">1.3.0.9.0.4.</span> <span class="toc-text">等待操作完成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#挂起和恢复队列"><span class="toc-number">1.3.0.9.0.5.</span> <span class="toc-text">挂起和恢复队列</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度队列-1"><span class="toc-number">1.4.</span> <span class="toc-text">调度队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于调度队列"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">关于调度队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列相关技术"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">队列相关技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用块实现任务"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">使用块实现任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建和管理调度队列"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">创建和管理调度队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#获取全局并发调度队列"><span class="toc-number">1.4.0.4.0.1.</span> <span class="toc-text">获取全局并发调度队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#创建串行调度队列"><span class="toc-number">1.4.0.4.0.2.</span> <span class="toc-text">创建串行调度队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在运行时获取通用队列"><span class="toc-number">1.4.0.4.0.3.</span> <span class="toc-text">在运行时获取通用队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#调度队列的内存管理"><span class="toc-number">1.4.0.4.0.4.</span> <span class="toc-text">调度队列的内存管理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#使用队列存储自定义上下文信息"><span class="toc-number">1.4.0.4.0.5.</span> <span class="toc-text">使用队列存储自定义上下文信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#提供队列的清理功能"><span class="toc-number">1.4.0.4.0.6.</span> <span class="toc-text">提供队列的清理功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将任务添加到队列"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">将任务添加到队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将单个任务添加到队列"><span class="toc-number">1.4.0.5.0.1.</span> <span class="toc-text">将单个任务添加到队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#完成任务后执行补全"><span class="toc-number">1.4.0.5.0.2.</span> <span class="toc-text">完成任务后执行补全</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同时执行循环迭代"><span class="toc-number">1.4.0.5.0.3.</span> <span class="toc-text">同时执行循环迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在主线程上执行任务"><span class="toc-number">1.4.0.5.0.4.</span> <span class="toc-text">在主线程上执行任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#在任务中使用-Objective-C-对象"><span class="toc-number">1.4.0.5.0.5.</span> <span class="toc-text">在任务中使用 Objective-C 对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂起和恢复队列-1"><span class="toc-number">1.4.0.6.</span> <span class="toc-text">挂起和恢复队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用调度信号量来调节有限资源的使用"><span class="toc-number">1.4.0.7.</span> <span class="toc-text">使用调度信号量来调节有限资源的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待排队的任务组"><span class="toc-number">1.4.0.8.</span> <span class="toc-text">等待排队的任务组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度队列和线程安全"><span class="toc-number">1.4.0.9.</span> <span class="toc-text">调度队列和线程安全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#派遣来源-1"><span class="toc-number">1.5.</span> <span class="toc-text">派遣来源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于调度源"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">关于调度源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建调度源"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">创建调度源</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#编写和安装事件处理程序"><span class="toc-number">1.5.0.2.0.1.</span> <span class="toc-text">编写和安装事件处理程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#安装取消处理程序"><span class="toc-number">1.5.0.2.0.2.</span> <span class="toc-text">安装取消处理程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#更改目标队列"><span class="toc-number">1.5.0.2.0.3.</span> <span class="toc-text">更改目标队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#将自定义数据与调度源关联"><span class="toc-number">1.5.0.2.0.4.</span> <span class="toc-text">将自定义数据与调度源关联</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#调度源的内存管理"><span class="toc-number">1.5.0.2.0.5.</span> <span class="toc-text">调度源的内存管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度源示例"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">调度源示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#创建一个计时器"><span class="toc-number">1.5.0.3.0.1.</span> <span class="toc-text">创建一个计时器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#从描述符读取数据"><span class="toc-number">1.5.0.3.0.2.</span> <span class="toc-text">从描述符读取数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#将数据写入描述符"><span class="toc-number">1.5.0.3.0.3.</span> <span class="toc-text">将数据写入描述符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#监视文件系统对象"><span class="toc-number">1.5.0.3.0.4.</span> <span class="toc-text">监视文件系统对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#监控信号"><span class="toc-number">1.5.0.3.0.5.</span> <span class="toc-text">监控信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#监控过程"><span class="toc-number">1.5.0.3.0.6.</span> <span class="toc-text">监控过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消派遣源"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">取消派遣源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#挂起和恢复派遣源"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">挂起和恢复派遣源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远离线程-1"><span class="toc-number">1.6.</span> <span class="toc-text">远离线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用调度队列替换线程"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">用调度队列替换线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消除基于锁的代码"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">消除基于锁的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#实现异步锁"><span class="toc-number">1.6.0.2.0.1.</span> <span class="toc-text">实现异步锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同步执行关键部分"><span class="toc-number">1.6.0.2.0.2.</span> <span class="toc-text">同步执行关键部分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改进循环代码"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">改进循环代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换线程连接"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">替换线程连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更改生产者-消费者实施"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">更改生产者-消费者实施</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换信号量代码"><span class="toc-number">1.6.0.6.</span> <span class="toc-text">替换信号量代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换运行循环代码"><span class="toc-number">1.6.0.7.</span> <span class="toc-text">替换运行循环代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与-POSIX-线程的兼容性"><span class="toc-number">1.6.0.8.</span> <span class="toc-text">与 POSIX 线程的兼容性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#词汇表"><span class="toc-number">1.7.</span> <span class="toc-text">词汇表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文档修订历史"><span class="toc-number">1.8.</span> <span class="toc-text">文档修订历史</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&text=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&is_video=false&description=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Concurrency Programming Guide&body=Check out this article: https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/" target="_blank" rel="noopener"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&title=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&name=Concurrency Programming Guide&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://leihao0.github.io/2020/05/27/Concurrency-Programming-Guide/&t=Concurrency Programming Guide" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2012-2020
    LeiHao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/donate/">Donate</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-159363268-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'Artwalk';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
